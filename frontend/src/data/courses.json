{
  "courses": [
    {
      "id": "java",
      "title": "Complete Java Guide",
      "description": "Master Java from basics to advanced level with comprehensive coverage of OOP, design patterns, and best practices.",
      "level": "Beginner to Advanced",
      "totalSections": 22,
      "estimatedHours": 40,
      "sections": [
        {
          "id": "1.1",
          "title": "Introduction to Java",
          "part": "Part 1: Java Fundamentals",
          "content": "### What is Java?\nJava is a **general-purpose, class-based, object-oriented programming language** designed to have as few implementation dependencies as possible. Key characteristics:\n\n- **Platform-independent**: \"Write Once, Run Anywhere\" (WORA)\n- **Secure**: Built-in security features and no direct memory access\n- **Robust**: Strong type-checking and exception handling\n- **Multi-threaded**: Native support for concurrent programming\n- **Compiled and Interpreted**: Java code is compiled to bytecode and interpreted by JVM\n\n### Java Architecture\n\n```\nSource Code (.java)\n    ↓\nJava Compiler (javac)\n    ↓\nBytecode (.class)\n    ↓\nJVM (Java Virtual Machine)\n    ↓\nOperating System → Hardware Execution\n```\n\n### Memory Concept\nThink of Java execution as:\n- **Compile-time**: Code is converted to bytecode (checked for syntax errors)\n- **Runtime**: JVM executes bytecode (checks logic errors)\n\n---"
        },
        {
          "id": "1.2",
          "title": "Basic Syntax & Program Structure",
          "part": "Part 1: Java Fundamentals",
          "content": "### Minimal Java Program\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n**Breaking Down the Code:**\n- `public`: Access modifier (visible everywhere)\n- `class`: Keyword to define a class\n- `HelloWorld`: Class name (must match filename)\n- `static`: Method belongs to class, not instance\n- `void`: Method returns nothing\n- `main()`: Entry point of program\n- `String[] args`: Command-line arguments\n- `System.out.println()`: Print to console with newline\n\n**Execution:**\n```bash\njavac HelloWorld.java    # Compile\njava HelloWorld          # Run\n```\n\n### Naming Conventions\n\n| Item | Convention | Example |\n|------|-----------|---------|\n| Class | PascalCase | `StudentManager`, `BankAccount` |\n| Method | camelCase | `calculateGPA()`, `getName()` |\n| Variable | camelCase | `studentName`, `totalMarks` |\n| Constant | UPPER_SNAKE_CASE | `MAX_AGE`, `PI_VALUE` |\n| Package | lowercase | `com.example.util` |\n\n### Memory Trick\n**Remember PSVM:** `public static void main` - The entrance gate to your program!\n\n---"
        },
        {
          "id": "1.3",
          "title": "Variables & Data Types",
          "part": "Part 1: Java Fundamentals",
          "content": "### Understanding Variables\n\nA variable is a **named storage location** that holds a value of a specific type.\n\n**Three Steps to Use Variables:**\n1. **Declaration**: Specify type and name\n2. **Initialization**: Assign initial value\n3. **Usage**: Read and modify value\n\n```java\n// Declaration + Initialization\nint age = 25;\ndouble salary = 50000.50;\nboolean isActive = true;\nchar grade = 'A';\nString name = \"John Doe\";\n\n// Can declare without initialization (later assign)\nint score;\nscore = 95;\n```\n\n### Primitive Data Types (8 Types)\n\n| Type | Size | Range | Default Value | Example |\n|------|------|-------|---------------|----------|\n| **byte** | 1 byte | -128 to 127 | 0 | `byte b = 10;` |\n| **short** | 2 bytes | -32,768 to 32,767 | 0 | `short s = 1000;` |\n| **int** | 4 bytes | -2,147,483,648 to 2,147,483,647 | 0 | `int i = 100000;` |\n| **long** | 8 bytes | -9.2 quintillion to 9.2 quintillion | 0L | `long l = 1000L;` |\n| **float** | 4 bytes | ±3.4 × 10^38 | 0.0f | `float f = 5.5f;` |\n| **double** | 8 bytes | ±1.7 × 10^308 | 0.0d | `double d = 5.5;` |\n| **char** | 2 bytes | 0 to 65,535 (Unicode) | '\\u0000' | `char c = 'A';` |\n| **boolean** | 1 bit | true / false | false | `boolean b = true;` |\n\n### Important Rules for Literals\n\n```java\n// Integers - suffix L for long\nint regularInt = 1000;\nlong bigNumber = 1000000L;\n\n// Floating-point - suffix f for float, d for double (default)\nfloat f = 5.5f;      // Must have 'f' suffix\ndouble d = 5.5;      // Can omit 'd'\ndouble d2 = 5.5d;    // Explicit\n\n// Characters - must be single quotes\nchar c = 'A';        // Correct\n// char c = \"A\";     // Wrong - would be String\n\n// Strings - double quotes\nString s = \"Hello\";  // Correct\n```\n\n### Reference Data Types\n\nUnlike primitives, reference types store addresses to objects in memory.\n\n```java\nString name = \"John\";           // String object\nint[] numbers = {1, 2, 3};     // Array\nArrayList<Integer> list = new ArrayList<>();  // ArrayList\n```\n\n### Type Casting\n\n**Implicit (Automatic) Casting:**\n```java\nint i = 10;\nlong l = i;              // Automatic - smaller to larger\ndouble d = i;            // Automatic - int to double\n```\n\n**Explicit (Manual) Casting:**\n```java\ndouble d = 10.5;\nint i = (int) d;         // Explicit - larger to smaller\n// Result: i = 10 (decimal part lost)\n\nlong l = 1000L;\nint i = (int) l;         // Explicit cast needed\n```\n\n**Memory Trick:** Implicit casting is like upgrading (always safe), explicit casting is like downgrading (might lose data).\n\n### Questions & Answers\n\n**Q1: Why does Java require explicit casting from double to int?**\n\nA: Because conversion from larger type (8 bytes) to smaller type (4 bytes) can lose data. The decimal part is truncated. Explicit casting shows the programmer is aware of potential data loss.\n\n**Q2: What's the difference between char and String?**\n\nA: `char` is a primitive type holding a single character (2 bytes). `String` is a reference type (object) holding a sequence of characters. `char` uses single quotes (`'A'`), `String` uses double quotes (`\"Hello\"`).\n\n**Q3: When should you use int vs long?**\n\nA: Use `int` (4 bytes, range ~2B) for normal numbers. Use `long` (8 bytes) for very large numbers. Mobile apps typically use `int` to save memory; big data applications use `long`.\n\n---"
        },
        {
          "id": "1.4",
          "title": "Operators",
          "part": "Part 1: Java Fundamentals",
          "content": "### Arithmetic Operators\n\n```java\nint a = 10, b = 3;\n\nint sum = a + b;        // 13 (Addition)\nint diff = a - b;       // 7 (Subtraction)\nint product = a * b;    // 30 (Multiplication)\nint quotient = a / b;   // 3 (Integer division)\nint remainder = a % b;  // 1 (Modulo)\n\n// Important: Integer division truncates\nint result = 7 / 2;     // 3, NOT 3.5\n\n// For decimal result, use double\ndouble result2 = 7.0 / 2;  // 3.5\n```\n\n### Comparison Operators (Return boolean)\n\n```java\nint a = 10, b = 20;\n\na == b;   // false (Equal to)\na != b;   // true (Not equal to)\na < b;    // true (Less than)\na > b;    // false (Greater than)\na <= b;   // true (Less than or equal)\na >= b;   // false (Greater than or equal)\n```\n\n### Logical Operators\n\n```java\nboolean a = true, b = false;\n\na && b;   // false (AND - both must be true)\na || b;   // true (OR - at least one must be true)\n!a;       // false (NOT - reverses boolean)\n\n// Short-circuit evaluation (important!)\nint x = 5;\nif (x < 10 && x > 0) { }    // Second condition checked\nif (x > 100 || x < 0) { }   // First false, second checked anyway\n```\n\n### Assignment Operators\n\n```java\nint x = 10;\n\nx += 5;     // x = x + 5 (15)\nx -= 3;     // x = x - 3 (12)\nx *= 2;     // x = x * 2 (24)\nx /= 4;     // x = x / 4 (6)\nx %= 5;     // x = x % 5 (1)\n```\n\n### Increment & Decrement\n\n```java\nint x = 5;\n\nx++;        // Post-increment: use then increment\nint a = x++;    // a = 5, then x = 6\n\n++x;        // Pre-increment: increment then use\nint b = ++x;    // x = 7, then b = 7\n\nx--;        // Post-decrement: use then decrement\nint c = x--;    // c = 7, then x = 6\n\n--x;        // Pre-decrement: decrement then use\nint d = --x;    // x = 5, then d = 5\n```\n\n### Operator Precedence (BODMAS in reverse)\n\n| Level | Operators |\n|-------|-----------|\n| 1 (Highest) | `++` `--` `!` (Unary) |\n| 2 | `*` `/` `%` |\n| 3 | `+` `-` |\n| 4 | `<` `>` `<=` `>=` |\n| 5 | `==` `!=` |\n| 6 | `&&` |\n| 7 | `\\|\\|` |\n| 8 (Lowest) | `=` `+=` `-=` etc |\n\n**Example:**\n```java\nint result = 10 + 20 * 2;   // 50 (multiplication first)\nint result = (10 + 20) * 2; // 60 (parentheses override)\n```\n\n---"
        },
        {
          "id": "1.5",
          "title": "Conditionals (Decision Making)",
          "part": "Part 1: Java Fundamentals",
          "content": "### if-else Statement\n\n```java\nint age = 20;\n\nif (age >= 18) {\n    System.out.println(\"Adult\");\n} else {\n    System.out.println(\"Minor\");\n}\n```\n\n### if-else-if Chain\n\n```java\nint score = 75;\n\nif (score >= 90) {\n    System.out.println(\"Grade: A\");\n} else if (score >= 80) {\n    System.out.println(\"Grade: B\");\n} else if (score >= 70) {\n    System.out.println(\"Grade: C\");\n} else {\n    System.out.println(\"Grade: F\");\n}\n```\n\n### Ternary Operator (Conditional Expression)\n\n```java\nint age = 20;\nString status = (age >= 18) ? \"Adult\" : \"Minor\";\n// Syntax: condition ? valueIfTrue : valueIfFalse\n\n// Nested ternary (not recommended - hard to read)\nString grade = (score >= 90) ? \"A\" : \n               (score >= 80) ? \"B\" : \n               (score >= 70) ? \"C\" : \"F\";\n```\n\n### switch Statement\n\n```java\nint day = 3;\n\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        break;      // Important! Prevents fall-through\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n    case 3:\n        System.out.println(\"Wednesday\");\n        break;\n    default:\n        System.out.println(\"Invalid day\");\n}\n```\n\n**Switch with Strings:**\n```java\nString fruit = \"apple\";\n\nswitch (fruit) {\n    case \"apple\":\n        System.out.println(\"Red fruit\");\n        break;\n    case \"banana\":\n        System.out.println(\"Yellow fruit\");\n        break;\n    default:\n        System.out.println(\"Unknown fruit\");\n}\n```\n\n**Switch Expression (Java 14+):**\n```java\nString result = switch (day) {\n    case 1 -> \"Monday\";\n    case 2 -> \"Tuesday\";\n    case 3 -> \"Wednesday\";\n    default -> \"Invalid\";\n};\n```\n\n### Common Mistakes\n\n```java\n// Wrong: Missing break causes fall-through\nswitch (day) {\n    case 1:\n        System.out.println(\"Monday\");\n        // No break! Falls through to next case\n    case 2:\n        System.out.println(\"Tuesday\");\n        break;\n}\n// If day=1, prints \"Monday\" AND \"Tuesday\"\n\n// Wrong: Can't use non-constant expressions\nswitch (x) {\n    case x + 1:    // ERROR - not a constant\n        break;\n}\n\n// Right: Use constants or literals\nswitch (x) {\n    case 1:\n    case 2:\n        System.out.println(\"One or Two\");\n        break;\n}\n```\n\n---"
        },
        {
          "id": "1.6",
          "title": "Loops",
          "part": "Part 1: Java Fundamentals",
          "content": "### for Loop (When you know iteration count)\n\n```java\nfor (int i = 0; i < 5; i++) {\n    System.out.println(i);  // 0 1 2 3 4\n}\n\n// Structure:\n// for (initialization; condition; increment/decrement) { body }\n\n// Decreasing loop\nfor (int i = 5; i >= 1; i--) {\n    System.out.println(i);  // 5 4 3 2 1\n}\n\n// Step by 2\nfor (int i = 0; i < 10; i += 2) {\n    System.out.println(i);  // 0 2 4 6 8\n}\n```\n\n### while Loop (When count is unknown)\n\n```java\nint count = 0;\nwhile (count < 5) {\n    System.out.println(count);\n    count++;\n}\n\n// Infinite loop (be careful!)\nwhile (true) {\n    System.out.println(\"Running...\");\n    if (someCondition) break;  // Exit condition needed\n}\n```\n\n### do-while Loop (Executes at least once)\n\n```java\nint x = 0;\ndo {\n    System.out.println(x);  // Runs even if condition is false\n    x++;\n} while (x < 0);\n\n// Output: 0 (printed even though x < 0 is false)\n```\n\n### for-each Loop (Iterate through arrays/collections)\n\n```java\nint[] numbers = {10, 20, 30, 40};\n\nfor (int num : numbers) {\n    System.out.println(num);\n}\n\n// For strings\nString[] names = {\"Alice\", \"Bob\", \"Charlie\"};\nfor (String name : names) {\n    System.out.println(name);\n}\n```\n\n### Loop Control Statements\n\n```java\n// break: Exit loop immediately\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) break;\n    System.out.println(i);  // 0 1 2 3 4\n}\n\n// continue: Skip current iteration\nfor (int i = 0; i < 5; i++) {\n    if (i == 2) continue;\n    System.out.println(i);  // 0 1 3 4 (skips 2)\n}\n\n// Label with break/continue (advanced)\nouterLoop:\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        if (j == 1) break outerLoop;\n        System.out.println(i + \" \" + j);\n    }\n}\n```\n\n### Loop Comparison\n\n| Loop Type | Best For | Characteristics |\n|-----------|----------|-----------------|\n| for | Known count | Initialize, condition, increment in one line |\n| while | Unknown count | Flexible condition checking |\n| do-while | At least once | Runs minimum 1 time |\n| for-each | Arrays/Collections | Clean syntax, read-only |\n\n**Memory Trick:** \n- `for` = Fixed iterations\n- `while` = Waiting for condition\n- `do-while` = Do first, ask later\n- `for-each` = For Each element\n\n---"
        },
        {
          "id": "1.7",
          "title": "Arrays",
          "part": "Part 1: Java Fundamentals",
          "content": "### Array Fundamentals\n\nAn array is a **collection of elements of the same data type** stored in contiguous memory locations.\n\n```java\n// Declaration\nint[] numbers;           // Declare only\n\n// Declaration + Initialization\nint[] numbers = new int[5];  // Array of 5 elements (default values 0)\nint[] numbers = {10, 20, 30, 40, 50};  // Array with values\n\n// Multi-line initialization\nint[] arr = {\n    1, 2, 3,\n    4, 5, 6\n};\n```\n\n### Accessing Array Elements\n\n```java\nint[] numbers = {10, 20, 30, 40, 50};\n\n// Access by index (0-indexed)\nint first = numbers[0];    // 10\nint third = numbers[2];    // 30\nint last = numbers[4];     // 50\n\n// Modify element\nnumbers[2] = 35;           // Change third element to 35\n\n// Array length\nint size = numbers.length; // 5\n\n// Iterate through array\nfor (int i = 0; i < numbers.length; i++) {\n    System.out.println(numbers[i]);\n}\n\n// Using for-each\nfor (int num : numbers) {\n    System.out.println(num);\n}\n```\n\n### Arrays of Objects\n\n```java\nString[] names = new String[3];\nnames[0] = \"Alice\";\nnames[1] = \"Bob\";\nnames[2] = \"Charlie\";\n\nfor (String name : names) {\n    System.out.println(name);\n}\n```\n\n### Multi-dimensional Arrays\n\n```java\n// 2D Array\nint[][] matrix = new int[3][3];\nint[][] matrix = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\n\n// Access\nint value = matrix[1][2];  // 6\nmatrix[0][0] = 10;\n\n// Iterate\nfor (int i = 0; i < matrix.length; i++) {\n    for (int j = 0; j < matrix[i].length; j++) {\n        System.out.print(matrix[i][j] + \" \");\n    }\n    System.out.println();\n}\n```\n\n### Array Common Mistakes\n\n```java\n// Wrong: Array index out of bounds\nint[] arr = {1, 2, 3};\nint x = arr[5];     // ERROR - only indices 0,1,2 exist\n\n// Wrong: Using length() on array (arrays don't have length())\nint len = arr.length();  // ERROR - array.length is property, not method\n\n// Correct\nint len = arr.length;    // 3 (no parentheses)\n\n// Wrong: Array initialization mismatch\nint[] arr = new int[3];\narr = {1, 2, 3, 4};  // ERROR - size mismatch after initialization\n\n// Correct: Initialize directly\nint[] arr = {1, 2, 3, 4};  // OK\nint[] arr = new int[]{1, 2, 3, 4};  // OK\n```\n\n### Important Array Methods\n\n```java\nint[] numbers = {5, 2, 8, 1, 9};\n\n// Sorting\njava.util.Arrays.sort(numbers);  // {1, 2, 5, 8, 9}\n\n// Searching (requires sorted array)\nint index = java.util.Arrays.binarySearch(numbers, 5);  // 2\n\n// Copying\nint[] copy = java.util.Arrays.copyOf(numbers, numbers.length);\n\n// Filling\njava.util.Arrays.fill(numbers, 0);  // Fill all with 0\n\n// Comparing\nboolean equal = java.util.Arrays.equals(arr1, arr2);\n```\n\n---"
        },
        {
          "id": "1.8",
          "title": "String and String Operations",
          "part": "Part 1: Java Fundamentals",
          "content": "### String Basics\n\n```java\n// String creation\nString s1 = \"Hello\";              // String literal\nString s2 = new String(\"Hello\");  // String object\n\n// Comparison (common mistake!)\nif (s1 == s2) { }       // Wrong - compares memory address\nif (s1.equals(s2)) { }  // Correct - compares content\n\n// Case-insensitive comparison\nif (s1.equalsIgnoreCase(s2)) { }\n```\n\n### String Methods\n\n```java\nString str = \"Hello World\";\n\n// Length\nint len = str.length();  // 11\n\n// Character access\nchar ch = str.charAt(0);  // 'H'\nchar ch = str.charAt(6);  // 'W'\n\n// Substring\nString sub = str.substring(0, 5);  // \"Hello\" (0-4 inclusive, 5 exclusive)\nString sub = str.substring(6);     // \"World\" (from index 6 to end)\n\n// Find character/substring\nint index = str.indexOf('o');     // 4 (first occurrence)\nint index = str.lastIndexOf('o'); // 7 (last occurrence)\nint index = str.indexOf(\"World\"); // 6\n\n// Case conversion\nString upper = str.toUpperCase();  // \"HELLO WORLD\"\nString lower = str.toLowerCase();  // \"hello world\"\n\n// Trimming whitespace\nString spaced = \"  Hello  \";\nString trimmed = spaced.trim();    // \"Hello\" (removes leading/trailing)\n\n// Replace\nString replaced = str.replace('o', '0');     // \"Hell0 W0rld\"\nString replaced = str.replace(\"World\", \"Java\"); // \"Hello Java\"\n\n// Split string\nString csv = \"apple,banana,orange\";\nString[] fruits = csv.split(\",\");  // {\"apple\", \"banana\", \"orange\"}\n\n// Check prefix/suffix\nboolean starts = str.startsWith(\"Hello\");  // true\nboolean ends = str.endsWith(\"World\");      // true\n\n// Contains\nboolean contains = str.contains(\"World\");  // true\n\n// Empty check\nString empty = \"\";\nboolean isEmpty = empty.isEmpty();  // true\nboolean isBlank = empty.isBlank();  // true (Java 11+)\n\n// String concatenation\nString greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\nString concat = \"Value: \" + 42;  // \"Value: 42\"\n```\n\n### String Immutability\n\n**Important Concept:** Strings are immutable in Java!\n\n```java\nString s = \"Hello\";\ns = s + \" World\";  // Creates NEW string, doesn't modify original\n// Original \"Hello\" still exists in memory (memory waste!)\n\n// More efficient: Use StringBuilder for multiple concatenations\nStringBuilder sb = new StringBuilder();\nsb.append(\"Hello\");\nsb.append(\" \");\nsb.append(\"World\");\nString result = sb.toString();  // \"Hello World\"\n\n// Or use StringBuffer for thread-safe version\n```\n\n### String Comparison Important Points\n\n```java\nString s1 = \"Hello\";\nString s2 = \"Hello\";\nString s3 = new String(\"Hello\");\n\ns1 == s2;           // true (same literal reference)\ns1 == s3;           // false (different objects)\ns1.equals(s2);      // true (same content)\ns1.equals(s3);      // true (same content)\n\n// Memory Trick: == checks reference, .equals() checks content\n```\n\n---"
        },
        {
          "id": "1.9",
          "title": "Methods",
          "part": "Part 1: Java Fundamentals",
          "content": "### Method Basics\n\nA method is a block of code that performs a specific task and can be reused.\n\n```java\n// Method definition\npublic static int add(int a, int b) {\n    return a + b;\n}\n\n// Method call\nint result = add(5, 3);  // result = 8\n```\n\n### Method Structure\n\n```\n[access_modifier] [static] [return_type] methodName([parameters]) {\n    // method body\n    return value;  // if return_type is not void\n}\n```\n\n**Example:**\n```java\npublic static double calculateGPA(double[] marks) {\n    double sum = 0;\n    for (double mark : marks) {\n        sum += mark;\n    }\n    return sum / marks.length;\n}\n```\n\n### Return Types\n\n```java\n// Returns integer\npublic static int getAge() {\n    return 25;\n}\n\n// Returns nothing (void)\npublic static void printMessage() {\n    System.out.println(\"Hello\");\n    // No return statement needed\n}\n\n// Returns boolean\npublic static boolean isEven(int num) {\n    return num % 2 == 0;\n}\n\n// Returns object\npublic static String getName() {\n    return \"John\";\n}\n```\n\n### Parameters and Arguments\n\n```java\n// Single parameter\npublic static void greet(String name) {\n    System.out.println(\"Hello, \" + name);\n}\n\n// Multiple parameters\npublic static int multiply(int a, int b) {\n    return a * b;\n}\n\n// No parameters\npublic static void welcome() {\n    System.out.println(\"Welcome!\");\n}\n\n// Variable number of arguments (varargs)\npublic static int sum(int... numbers) {\n    int total = 0;\n    for (int num : numbers) {\n        total += num;\n    }\n    return total;\n}\n\n// Usage\nsum(5, 10);           // 15\nsum(5, 10, 15, 20);   // 50\n```\n\n### Method Overloading\n\nSame method name, different parameter types/count.\n\n```java\npublic static void display(int x) {\n    System.out.println(\"Int: \" + x);\n}\n\npublic static void display(double x) {\n    System.out.println(\"Double: \" + x);\n}\n\npublic static void display(String x) {\n    System.out.println(\"String: \" + x);\n}\n\npublic static void display(int x, int y) {\n    System.out.println(\"Two ints: \" + x + \", \" + y);\n}\n\n// Compiler determines which to call based on arguments\ndisplay(5);            // Calls first version\ndisplay(5.5);          // Calls second version\ndisplay(\"Hello\");      // Calls third version\ndisplay(5, 10);        // Calls fourth version\n```\n\n### Problems with Solutions\n\n#### Problem 1: Prime Number Checker\n\n**Problem:** Check if a number is prime.\n\n**Solution:**\n```java\npublic static boolean isPrime(int number) {\n    if (number < 2) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n    \n    for (int i = 3; i <= Math.sqrt(number); i += 2) {\n        if (number % i == 0) return false;\n    }\n    return true;\n}\n\npublic static void main(String[] args) {\n    System.out.println(isPrime(17));   // true\n    System.out.println(isPrime(20));   // false\n    System.out.println(isPrime(1));    // false\n}\n```\n\n**Test Cases:**\n- Input: 2 → Output: true (smallest prime)\n- Input: 17 → Output: true\n- Input: 20 → Output: false\n- Input: 1 → Output: false (not prime by definition)\n\n#### Problem 2: Factorial Calculator\n\n**Problem:** Calculate factorial of a number (n! = n × (n-1) × ... × 1)\n\n**Solution:**\n```java\npublic static long factorial(int n) {\n    if (n < 0) return -1;  // Invalid\n    if (n == 0 || n == 1) return 1;\n    \n    long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\npublic static void main(String[] args) {\n    System.out.println(factorial(5));   // 120\n    System.out.println(factorial(0));   // 1\n    System.out.println(factorial(10));  // 3628800\n}\n```\n\n**Test Cases:**\n- Input: 0 → Output: 1 (0! = 1)\n- Input: 1 → Output: 1 (1! = 1)\n- Input: 5 → Output: 120 (5! = 5×4×3×2×1)\n- Input: 10 → Output: 3628800\n\n#### Problem 3: String Reversal\n\n**Problem:** Reverse a string without using built-in reverse method.\n\n**Solution:**\n```java\npublic static String reverseString(String str) {\n    String reversed = \"\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n        reversed += str.charAt(i);\n    }\n    return reversed;\n}\n\n// Better approach using StringBuilder\npublic static String reverseStringOptimal(String str) {\n    return new StringBuilder(str).reverse().toString();\n}\n\npublic static void main(String[] args) {\n    System.out.println(reverseString(\"Hello\"));      // \"olleH\"\n    System.out.println(reverseString(\"Java\"));       // \"avaJ\"\n    System.out.println(reverseString(\"12345\"));      // \"54321\"\n}\n```\n\n**Test Cases:**\n- Input: \"Hello\" → Output: \"olleH\"\n- Input: \"Java\" → Output: \"avaJ\"\n- Input: \"a\" → Output: \"a\" (single character)\n- Input: \"\" → Output: \"\" (empty string)\n\n---\n\n# PART 2: OBJECT-ORIENTED PROGRAMMING (INTERMEDIATE LEVEL)"
        },
        {
          "id": "2.1",
          "title": "Classes and Objects",
          "part": "Part 2: Object-Oriented Programming",
          "content": "### What are Classes and Objects?\n\n- **Class:** Blueprint or template for creating objects\n- **Object:** Instance of a class (actual entity with memory)\n\n**Analogy:** Class is like a cookie cutter (template), objects are actual cookies made from it.\n\n### Basic Class Structure\n\n```java\npublic class Student {\n    // Attributes (Instance Variables)\n    private String name;\n    private int rollNumber;\n    private double gpa;\n    \n    // Constructor (Initializer)\n    public Student(String name, int rollNumber, double gpa) {\n        this.name = name;\n        this.rollNumber = rollNumber;\n        this.gpa = Math.min(4.0, Math.max(0, gpa));  // Validate\n    }\n    \n    // Getter methods\n    public String getName() {\n        return name;\n    }\n    \n    public int getRollNumber() {\n        return rollNumber;\n    }\n    \n    public double getGPA() {\n        return gpa;\n    }\n    \n    // Setter methods\n    public void setGPA(double newGPA) {\n        this.gpa = Math.min(4.0, Math.max(0, newGPA));\n    }\n    \n    // Business method\n    public void displayInfo() {\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Roll: \" + rollNumber);\n        System.out.println(\"GPA: \" + String.format(\"%.2f\", gpa));\n    }\n}\n```\n\n### Creating and Using Objects\n\n```java\n// Create object\nStudent student1 = new Student(\"Alice\", 101, 3.8);\nStudent student2 = new Student(\"Bob\", 102, 3.5);\n\n// Access methods\nstudent1.displayInfo();\ndouble gpa = student1.getGPA();\n\n// Modify using setter\nstudent1.setGPA(3.9);\n\n// Null reference\nStudent student3 = null;\n// student3.displayInfo();  // Would cause NullPointerException\n```\n\n### The `this` Keyword\n\n`this` refers to the current object instance.\n\n```java\npublic class Car {\n    private String color;\n    private String brand;\n    \n    public Car(String color, String brand) {\n        this.color = color;      // this.color = instance variable\n        this.brand = brand;      // color = parameter\n    }\n    \n    public void paint(String color) {\n        this.color = color;      // Distinguish between local and instance\n    }\n    \n    public Car getThis() {\n        return this;             // Return current object\n    }\n}\n```\n\n### Constructors\n\nConstructors initialize objects. Called automatically with `new` keyword.\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n    \n    // No-argument constructor\n    public Person() {\n        name = \"Unknown\";\n        age = 0;\n    }\n    \n    // Parameterized constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Constructor overloading\n    public Person(String name) {\n        this.name = name;\n        this.age = 0;\n    }\n}\n\n// Usage\nPerson p1 = new Person();              // Calls no-arg constructor\nPerson p2 = new Person(\"John\", 25);    // Calls parameterized constructor\nPerson p3 = new Person(\"Jane\");        // Calls another constructor\n```\n\n### Access Modifiers\n\n| Modifier | Class | Package | Subclass | World |\n|----------|-------|---------|----------|-------|\n| public | ✓ | ✓ | ✓ | ✓ |\n| protected | ✓ | ✓ | ✓ | ✗ |\n| default | ✓ | ✓ | ✗ | ✗ |\n| private | ✓ | ✗ | ✗ | ✗ |\n\n```java\npublic class Example {\n    public int publicVar;        // Accessible everywhere\n    protected int protectedVar;  // Accessible in subclasses\n    int defaultVar;              // Accessible only in same package\n    private int privateVar;      // Accessible only in this class\n    \n    public void publicMethod() { }\n    private void privateMethod() { }\n}\n```\n\n**Best Practice:** Make attributes private, provide public getters/setters.\n\n---"
        },
        {
          "id": "2.2",
          "title": "Inheritance",
          "part": "Part 2: Object-Oriented Programming",
          "content": "### Inheritance Concept\n\nInheritance allows a class to acquire properties and methods from another class.\n\n**Real-World Example:**\n```\n        Animal\n         /  \\\n      Dog   Cat\n       |     |\n    Poodle  Persian\n```\n\n### Basic Inheritance\n\n```java\n// Parent/Superclass\npublic class Animal {\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public void sound() {\n        System.out.println(\"Generic animal sound\");\n    }\n    \n    public void sleep() {\n        System.out.println(name + \" is sleeping\");\n    }\n}\n\n// Child/Subclass\npublic class Dog extends Animal {\n    private String breed;\n    \n    public Dog(String name, String breed) {\n        super(name);         // Call parent constructor\n        this.breed = breed;\n    }\n    \n    @Override\n    public void sound() {\n        System.out.println(name + \" barks: Woof! Woof!\");\n    }\n    \n    public void fetch() {\n        System.out.println(name + \" is fetching the ball\");\n    }\n}\n\n// Usage\nDog dog = new Dog(\"Buddy\", \"Golden Retriever\");\ndog.sound();    // \"Buddy barks: Woof! Woof!\" (overridden)\ndog.sleep();    // \"Buddy is sleeping\" (inherited)\ndog.fetch();    // \"Buddy is fetching the ball\" (own method)\n```\n\n### super Keyword\n\nUsed to call parent class methods/constructors.\n\n```java\npublic class Manager extends Employee {\n    private double bonus;\n    \n    public Manager(String name, double salary, double bonus) {\n        super(name, salary);   // Call parent constructor\n        this.bonus = bonus;\n    }\n    \n    @Override\n    public double calculateSalary() {\n        return super.calculateSalary() + bonus;  // Call parent method\n    }\n}\n```\n\n### Method Overriding Rules\n\n```java\n// Parent class\npublic class Vehicle {\n    public void start() {\n        System.out.println(\"Vehicle starting\");\n    }\n}\n\n// Child class - Correct override\npublic class Car extends Vehicle {\n    @Override  // Annotation (optional but recommended)\n    public void start() {\n        System.out.println(\"Car starting with engine\");\n    }\n}\n\n// Wrong attempts:\n// 1. Different return type (not compatible)\n//    public int start() { }  // ERROR\n//\n// 2. Different parameters\n//    public void start(String type) { }  // This is overloading, not overriding\n//\n// 3. Cannot reduce visibility\n//    private void start() { }  // ERROR (was public in parent)\n```\n\n---"
        },
        {
          "id": "2.3",
          "title": "Polymorphism",
          "part": "Part 2: Object-Oriented Programming",
          "content": "### Method Overriding (Runtime/Dynamic Polymorphism)\n\n```java\npublic class PaymentSystem {\n    public static void processPayment(PaymentMethod payment) {\n        payment.process();  // Calls appropriate subclass method\n    }\n}\n\n// Parent class\npublic abstract class PaymentMethod {\n    public abstract void process();\n}\n\n// Implementations\npublic class CreditCard extends PaymentMethod {\n    @Override\n    public void process() {\n        System.out.println(\"Processing credit card payment\");\n    }\n}\n\npublic class PayPal extends PaymentMethod {\n    @Override\n    public void process() {\n        System.out.println(\"Processing PayPal payment\");\n    }\n}\n\npublic class Bitcoin extends PaymentMethod {\n    @Override\n    public void process() {\n        System.out.println(\"Processing Bitcoin payment\");\n    }\n}\n\n// Usage\nPaymentMethod[] payments = {\n    new CreditCard(),\n    new PayPal(),\n    new Bitcoin()\n};\n\nfor (PaymentMethod payment : payments) {\n    payment.process();  // Each calls its own version\n}\n```\n\n**Output:**\n```\nProcessing credit card payment\nProcessing PayPal payment\nProcessing Bitcoin payment\n```\n\n### Method Overloading (Compile-time/Static Polymorphism)\n\nSame method name, different parameters, same class.\n\n```java\npublic class Calculator {\n    // Add two integers\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    // Add three integers\n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n    \n    // Add two doubles\n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    // Add array of integers\n    public int add(int[] numbers) {\n        int sum = 0;\n        for (int num : numbers) sum += num;\n        return sum;\n    }\n}\n\n// Usage\nCalculator calc = new Calculator();\nSystem.out.println(calc.add(5, 10));              // 15\nSystem.out.println(calc.add(5, 10, 15));         // 30\nSystem.out.println(calc.add(5.5, 10.5));         // 16.0\nSystem.out.println(calc.add(new int[]{1, 2, 3, 4})); // 10\n```\n\n### instanceof Operator\n\nCheck if object is instance of class.\n\n```java\nAnimal dog = new Dog(\"Buddy\", \"Labrador\");\n\nif (dog instanceof Dog) {\n    Dog d = (Dog) dog;\n    d.fetch();\n}\n\nif (dog instanceof Animal) {\n    System.out.println(\"It's an animal\");\n}\n\n// Safe casting pattern\nif (dog instanceof Dog) {\n    ((Dog) dog).fetch();\n}\n```\n\n---"
        },
        {
          "id": "2.4",
          "title": "Encapsulation",
          "part": "Part 2: Object-Oriented Programming",
          "content": "Bundling data and methods together while hiding internal details.\n\n```java\npublic class BankAccount {\n    // Private data (hidden from outside)\n    private String accountNumber;\n    private double balance;\n    private String accountHolder;\n    \n    public BankAccount(String accountHolder, double initialBalance) {\n        this.accountHolder = accountHolder;\n        this.balance = Math.max(0, initialBalance);\n        this.accountNumber = generateAccountNumber();\n    }\n    \n    // Public interface (controlled access)\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: \" + amount);\n        } else {\n            System.out.println(\"Invalid amount\");\n        }\n    }\n    \n    public boolean withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: \" + amount);\n            return true;\n        }\n        System.out.println(\"Insufficient balance\");\n        return false;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n    \n    // Private helper method\n    private String generateAccountNumber() {\n        return \"ACC\" + System.currentTimeMillis();\n    }\n}\n```\n\n**Benefits:**\n1. **Data Protection:** Cannot modify balance directly\n2. **Validation:** All changes go through methods with checks\n3. **Flexibility:** Can change implementation without affecting external code\n4. **Security:** Internal details hidden\n\n---"
        },
        {
          "id": "2.5",
          "title": "Abstraction",
          "part": "Part 2: Object-Oriented Programming",
          "content": "Showing only essential features, hiding complexity.\n\n### Abstract Classes\n\n```java\n// Abstract class (cannot be instantiated)\npublic abstract class Shape {\n    protected String color;\n    \n    public Shape(String color) {\n        this.color = color;\n    }\n    \n    // Abstract method (must be implemented by subclasses)\n    public abstract double calculateArea();\n    \n    // Concrete method (implementation provided)\n    public void displayColor() {\n        System.out.println(\"Color: \" + color);\n    }\n}\n\n// Concrete subclass\npublic class Circle extends Shape {\n    private double radius;\n    \n    public Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\n// Usage\n// Shape s = new Shape(\"Red\");  // ERROR - cannot instantiate abstract class\nShape s = new Circle(\"Red\", 5);\nSystem.out.println(s.calculateArea());  // 78.54\ns.displayColor();                       // Color: Red\n```\n\n### Interfaces\n\n```java\n// Interface (contract/specification)\npublic interface Animal {\n    void sound();           // Abstract method\n    void sleep();\n    \n    default void eat() {    // Default implementation\n        System.out.println(\"Eating...\");\n    }\n}\n\n// Implementing interface\npublic class Dog implements Animal {\n    @Override\n    public void sound() {\n        System.out.println(\"Woof!\");\n    }\n    \n    @Override\n    public void sleep() {\n        System.out.println(\"Dog sleeping\");\n    }\n    \n    // Can use inherited default method or override it\n}\n\n// A class can implement multiple interfaces\npublic class Robot implements Animal, Machine {\n    // Must implement methods from both interfaces\n}\n\n// Usage\nAnimal dog = new Dog();\ndog.sound();  // Woof!\ndog.eat();    // Eating... (inherited default)\n```\n\n**Abstract Class vs Interface:**\n\n| Feature | Abstract Class | Interface |\n|---------|---|---|\n| Instantiation | Cannot | Cannot |\n| Methods | Can have any | Only abstract or default/static |\n| Variables | Any type | Only constants (public static final) |\n| Inheritance | extends (one) | implements (multiple) |\n| Access Modifiers | Any | Usually public |\n| Use Case | \"IS-A\" relationship | \"CAN-DO\" contract |\n\n---\n\n# PART 3: ADVANCED JAVA CONCEPTS"
        },
        {
          "id": "3.1",
          "title": "Collections Framework",
          "part": "Part 3: Advanced Java Concepts",
          "content": "### ArrayList vs Array\n\n| Feature | Array | ArrayList |\n|---------|-------|-----------|\n| Size | Fixed | Dynamic |\n| Declaration | `int[] arr = new int[5];` | `ArrayList<Integer> list = new ArrayList<>();` |\n| Type Safety | Generic (T[]) | Generics `<T>` |\n| Methods | Few | Many (add, remove, contains, etc.) |\n| Performance | Faster | Slightly slower |\n\n### ArrayList Operations\n\n```java\nimport java.util.ArrayList;\n\nArrayList<String> list = new ArrayList<>();\n\n// Add elements\nlist.add(\"Java\");           // Add at end\nlist.add(0, \"Python\");      // Add at index\n\n// Remove elements\nlist.remove(0);             // Remove by index\nlist.remove(\"Java\");        // Remove by value\nlist.clear();               // Remove all\n\n// Get elements\nString element = list.get(0);\nint size = list.size();\n\n// Check existence\nboolean contains = list.contains(\"Python\");\n\n// Iterate\nfor (String lang : list) {\n    System.out.println(lang);\n}\n\n// Using iterator\nIterator<String> it = list.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}\n```\n\n### Set Interface\n\nUnique elements, no duplicates.\n\n```java\nimport java.util.*;\n\n// HashSet - unordered, fast\nSet<Integer> hashSet = new HashSet<>();\nhashSet.add(5);\nhashSet.add(2);\nhashSet.add(8);\nhashSet.add(5);  // Duplicate ignored\nSystem.out.println(hashSet);  // {2, 5, 8} (order may vary)\n\n// TreeSet - sorted order\nSet<Integer> treeSet = new TreeSet<>();\ntreeSet.add(5);\ntreeSet.add(2);\ntreeSet.add(8);\nSystem.out.println(treeSet);  // [2, 5, 8] (sorted)\n\n// LinkedHashSet - insertion order\nSet<Integer> linkedSet = new LinkedHashSet<>();\nlinkedSet.add(5);\nlinkedSet.add(2);\nlinkedSet.add(8);\nSystem.out.println(linkedSet);  // [5, 2, 8] (insertion order)\n\n// Set operations\nhashSet.add(10);\nhashSet.remove(5);\nboolean empty = hashSet.isEmpty();\n```\n\n### Map Interface\n\nKey-value pairs.\n\n```java\nimport java.util.*;\n\n// HashMap - unordered\nMap<Integer, String> hashMap = new HashMap<>();\nhashMap.put(1, \"Alice\");\nhashMap.put(2, \"Bob\");\nhashMap.put(3, \"Charlie\");\n\n// Access\nString value = hashMap.get(1);  // \"Alice\"\n\n// Check key/value existence\nboolean hasKey = hashMap.containsKey(1);      // true\nboolean hasValue = hashMap.containsValue(\"Bob\");  // true\n\n// Remove\nhashMap.remove(2);\n\n// Iterate\nfor (Map.Entry<Integer, String> entry : hashMap.entrySet()) {\n    System.out.println(entry.getKey() + \": \" + entry.getValue());\n}\n\n// TreeMap - sorted by key\nMap<Integer, String> treeMap = new TreeMap<>();\ntreeMap.put(3, \"Charlie\");\ntreeMap.put(1, \"Alice\");\ntreeMap.put(2, \"Bob\");\n// Iterates in key order: 1, 2, 3\n\n// Get all keys\nSet<Integer> keys = hashMap.keySet();\n\n// Get all values\nCollection<String> values = hashMap.values();\n```\n\n### Queue Interface (FIFO - First In First Out)\n\n```java\nimport java.util.*;\n\nQueue<Integer> queue = new LinkedList<>();\n\n// Add elements\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\n\n// Remove from front\nint first = queue.remove();      // 1 (throws exception if empty)\nint first = queue.poll();        // 1 (returns null if empty)\n\n// View front without removing\nint front = queue.peek();        // 2 (returns null if empty)\nint front = queue.element();     // 2 (throws exception if empty)\n\n// Check if empty\nboolean empty = queue.isEmpty();\n\n// Size\nint size = queue.size();\n```\n\n### Stack (LIFO - Last In First Out)\n\n```java\nimport java.util.*;\n\nStack<Integer> stack = new Stack<>();\n\n// Push (add)\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop (remove from top)\nint top = stack.pop();  // 3\n\n// Peek (view without removing)\nint peek = stack.peek();  // 2\n\n// Check if empty\nboolean empty = stack.isEmpty();\n\n// Search\nint position = stack.search(2);  // Distance from top (1-indexed)\n```\n\n---"
        },
        {
          "id": "3.2",
          "title": "Exception Handling",
          "part": "Part 3: Advanced Java Concepts",
          "content": "### Exception Hierarchy\n\n```\nThrowable\n  ├── Exception (Checked - must handle)\n  │   ├── IOException\n  │   ├── SQLException\n  │   └── ...\n  └── RuntimeException (Unchecked - optional to handle)\n      ├── NullPointerException\n      ├── ArrayIndexOutOfBoundsException\n      ├── ArithmeticException\n      └── ...\n```\n\n### try-catch-finally\n\n```java\ntry {\n    // Code that might throw exception\n    int[] arr = {1, 2, 3};\n    int value = arr[5];  // ArrayIndexOutOfBoundsException\n    \n} catch (ArrayIndexOutOfBoundsException e) {\n    System.out.println(\"Array index out of bounds: \" + e.getMessage());\n    \n} catch (NullPointerException e) {\n    System.out.println(\"Null pointer exception\");\n    \n} catch (Exception e) {  // Catch-all (must be last)\n    System.out.println(\"Some exception occurred\");\n    e.printStackTrace();  // Print stack trace\n    \n} finally {\n    // Always executes (cleanup code)\n    System.out.println(\"Cleanup done\");\n}\n```\n\n### Multiple Exceptions in One Catch (Java 7+)\n\n```java\ntry {\n    // risky code\n} catch (IOException | SQLException | ParseException e) {\n    System.out.println(\"Error: \" + e.getMessage());\n}\n```\n\n### throws Keyword\n\nMethod declares it might throw exception (caller must handle).\n\n```java\npublic static void readFile(String filename) throws IOException {\n    FileInputStream file = new FileInputStream(filename);\n    // If file not found, IOException is thrown\n}\n\n// Caller must handle\ntry {\n    readFile(\"data.txt\");\n} catch (IOException e) {\n    System.out.println(\"File not found\");\n}\n```\n\n### Custom Exceptions\n\n```java\n// Define custom exception\npublic class InvalidAgeException extends Exception {\n    public InvalidAgeException(String message) {\n        super(message);\n    }\n}\n\n// Usage\npublic static void validateAge(int age) throws InvalidAgeException {\n    if (age < 0 || age > 120) {\n        throw new InvalidAgeException(\"Age must be between 0 and 120\");\n    }\n}\n\n// Handle\ntry {\n    validateAge(-5);\n} catch (InvalidAgeException e) {\n    System.out.println(e.getMessage());\n}\n```\n\n---"
        },
        {
          "id": "3.3",
          "title": "Generics",
          "part": "Part 3: Advanced Java Concepts",
          "content": "### Why Generics?\n\nType safety at compile time.\n\n```java\n// Without generics (not type-safe)\nArrayList list = new ArrayList();\nlist.add(\"Java\");\nlist.add(123);\nlist.add(true);\n\n// Must cast (errors at runtime)\nfor (Object obj : list) {\n    String str = (String) obj;  // ClassCastException possible\n}\n\n// With generics (type-safe)\nArrayList<String> list = new ArrayList<String>();\nlist.add(\"Java\");\nlist.add(123);      // ERROR at compile time - prevented!\n\n// No casting needed\nfor (String str : list) {\n    System.out.println(str);\n}\n```\n\n### Generic Methods\n\n```java\n// Generic method\npublic static <T> void printArray(T[] array) {\n    for (T element : array) {\n        System.out.println(element);\n    }\n}\n\n// Usage\nprintArray(new Integer[]{1, 2, 3});\nprintArray(new String[]{\"a\", \"b\", \"c\"});\n\n// Generic method with constraints\npublic static <T extends Number> double average(T[] numbers) {\n    double sum = 0;\n    for (T num : numbers) {\n        sum += num.doubleValue();\n    }\n    return sum / numbers.length;\n}\n```\n\n### Generic Classes\n\n```java\npublic class Box<T> {\n    private T content;\n    \n    public void set(T content) {\n        this.content = content;\n    }\n    \n    public T get() {\n        return content;\n    }\n}\n\n// Usage\nBox<String> stringBox = new Box<>();\nstringBox.set(\"Hello\");\nString str = stringBox.get();\n\nBox<Integer> intBox = new Box<>();\nintBox.set(42);\nInteger num = intBox.get();\n```\n\n### Wildcards\n\n```java\n// Accept any type\npublic static void printList(List<?> list) {\n    for (Object obj : list) {\n        System.out.println(obj);\n    }\n}\n\n// Accept subclass of Number\npublic static double sum(List<? extends Number> numbers) {\n    double total = 0;\n    for (Number num : numbers) {\n        total += num.doubleValue();\n    }\n    return total;\n}\n\n// Accept superclass (producer)\npublic static void addNumbers(List<? super Integer> list) {\n    list.add(1);\n    list.add(2);\n}\n```\n\n---"
        },
        {
          "id": "3.4",
          "title": "Streams API (Java 8+)",
          "part": "Part 3: Advanced Java Concepts",
          "content": "Functional programming approach to collections.\n\n```java\nimport java.util.stream.*;\n\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n// Filter - keep only even numbers\nList<Integer> evens = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .collect(Collectors.toList());\n\n// Map - transform elements\nList<Integer> squared = numbers.stream()\n    .map(n -> n * n)\n    .collect(Collectors.toList());\n\n// ForEach\nnumbers.stream()\n    .filter(n -> n > 5)\n    .forEach(System.out::println);\n\n// Reduce - aggregate\nint sum = numbers.stream()\n    .reduce(0, (a, b) -> a + b);\n\n// Count\nlong count = numbers.stream()\n    .filter(n -> n > 5)\n    .count();\n\n// Terminal operations\nlong total = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .count();  // Returns result\n\nboolean anyEven = numbers.stream()\n    .anyMatch(n -> n % 2 == 0);  // true\n\nboolean allPositive = numbers.stream()\n    .allMatch(n -> n > 0);  // true\n```\n\n### Lambda Expressions\n\n```java\n// Traditional (verbose)\nlist.forEach(new Consumer<Integer>() {\n    @Override\n    public void accept(Integer n) {\n        System.out.println(n);\n    }\n});\n\n// Lambda expression (concise)\nlist.forEach(n -> System.out.println(n));\n\n// Method reference\nlist.forEach(System.out::println);\n\n// Stream with lambda\nnumbers.stream()\n    .filter(n -> n > 5)\n    .map(n -> n * 2)\n    .forEach(n -> System.out.println(n));\n```\n\n---"
        },
        {
          "id": "3.5",
          "title": "File I/O",
          "part": "Part 3: Advanced Java Concepts",
          "content": "### Reading Files\n\n```java\nimport java.nio.file.*;\n\n// Simple reading\nList<String> lines = Files.readAllLines(Paths.get(\"file.txt\"));\nfor (String line : lines) {\n    System.out.println(line);\n}\n\n// Using BufferedReader\ntry (BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}\n\n// Stream approach\nFiles.lines(Paths.get(\"file.txt\"))\n    .forEach(System.out::println);\n```\n\n### Writing Files\n\n```java\n// Write all at once\nFiles.write(Paths.get(\"output.txt\"), \"Hello World\".getBytes());\n\n// Append to file\nFiles.write(\n    Paths.get(\"output.txt\"),\n    \"New line\".getBytes(),\n    StandardOpenOption.APPEND\n);\n\n// Using BufferedWriter\ntry (BufferedWriter writer = new BufferedWriter(new FileWriter(\"output.txt\"))) {\n    writer.write(\"Line 1\");\n    writer.newLine();\n    writer.write(\"Line 2\");\n}\n```\n\n---"
        },
        {
          "id": "3.6",
          "title": "Multithreading",
          "part": "Part 3: Advanced Java Concepts",
          "content": "### Thread Basics\n\n```java\n// Method 1: Extend Thread class\npublic class MyThread extends Thread {\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"Thread: \" + i);\n            try {\n                Thread.sleep(1000);  // Sleep 1 second\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// Method 2: Implement Runnable interface (preferred)\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"Running: \" + i);\n        }\n    }\n}\n\n// Usage\nThread t1 = new Thread(new MyRunnable());\nt1.start();  // Start thread (don't call run() directly)\n\n// Lambda approach (Java 8+)\nThread t2 = new Thread(() -> {\n    System.out.println(\"Lambda thread\");\n});\nt2.start();\n```\n\n### Thread Synchronization\n\nPrevent race conditions when multiple threads access shared resource.\n\n```java\npublic class Counter {\n    private int count = 0;\n    \n    // Synchronized method\n    public synchronized void increment() {\n        count++;\n    }\n    \n    public synchronized int getCount() {\n        return count;\n    }\n}\n\n// Or use synchronized block\npublic class Counter {\n    private int count = 0;\n    private final Object lock = new Object();\n    \n    public void increment() {\n        synchronized (lock) {\n            count++;\n        }\n    }\n}\n```\n\n---\n\n# PART 4: DESIGN PATTERNS & BEST PRACTICES"
        },
        {
          "id": "4.1",
          "title": "Design Patterns",
          "part": "Part 4: Design Patterns & Best Practices",
          "content": "### Singleton Pattern\n\nEnsure only one instance of a class exists.\n\n```java\npublic class Singleton {\n    private static Singleton instance;\n    \n    private Singleton() {\n        // Private constructor prevents instantiation\n    }\n    \n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// Usage\nSingleton s1 = Singleton.getInstance();\nSingleton s2 = Singleton.getInstance();\n// s1 == s2  (true - same instance)\n```\n\n### Factory Pattern\n\nCreate objects without specifying exact classes.\n\n```java\n// Interface\npublic interface Vehicle {\n    void drive();\n}\n\n// Implementations\npublic class Car implements Vehicle {\n    @Override\n    public void drive() {\n        System.out.println(\"Driving car\");\n    }\n}\n\npublic class Bike implements Vehicle {\n    @Override\n    public void drive() {\n        System.out.println(\"Riding bike\");\n    }\n}\n\n// Factory\npublic class VehicleFactory {\n    public static Vehicle createVehicle(String type) {\n        if (\"car\".equalsIgnoreCase(type)) {\n            return new Car();\n        } else if (\"bike\".equalsIgnoreCase(type)) {\n            return new Bike();\n        }\n        return null;\n    }\n}\n\n// Usage\nVehicle vehicle = VehicleFactory.createVehicle(\"car\");\nvehicle.drive();  // Driving car\n```\n\n### Observer Pattern\n\nNotify multiple objects about state changes.\n\n```java\n// Subject\npublic class Subject {\n    private List<Observer> observers = new ArrayList<>();\n    private int value;\n    \n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    public void setValue(int value) {\n        this.value = value;\n        notifyObservers();\n    }\n    \n    private void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(value);\n        }\n    }\n}\n\n// Observer interface\npublic interface Observer {\n    void update(int value);\n}\n\n// Concrete observers\npublic class ConcreteObserver implements Observer {\n    private String name;\n    \n    public ConcreteObserver(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void update(int value) {\n        System.out.println(name + \": Value changed to \" + value);\n    }\n}\n```\n\n---"
        },
        {
          "id": "4.2",
          "title": "Best Practices",
          "part": "Part 4: Design Patterns & Best Practices",
          "content": "### Code Organization\n\n```java\n// Good: Organized, readable\npublic class Student {\n    // Constants first\n    private static final int MAX_GPA = 4;\n    \n    // Instance variables\n    private String name;\n    private double gpa;\n    \n    // Constructor\n    public Student(String name, double gpa) {\n        this.name = name;\n        this.gpa = Math.min(MAX_GPA, Math.max(0, gpa));\n    }\n    \n    // Getters/Setters\n    public String getName() { return name; }\n    public double getGPA() { return gpa; }\n    public void setGPA(double gpa) { this.gpa = gpa; }\n    \n    // Business methods\n    public void display() { }\n    \n    // Utility methods\n    private String formatGPA() { return String.format(\"%.2f\", gpa); }\n}\n```\n\n### Naming Conventions\n\n```java\n// Good names - self-documenting\ndouble totalPrice;\nArrayList<Student> studentList;\nboolean isActive;\nvoid calculateMonthlyPayment() { }\n\n// Bad names - unclear\ndouble tp;  // What is tp?\nArrayList<Object> list;\nboolean b;\nvoid process() { }  // Process what?\n```\n\n### Error Handling\n\n```java\n// Bad: Ignoring exceptions\ntry {\n    // code\n} catch (Exception e) {\n    // silently ignore\n}\n\n// Better: Log and handle\ntry {\n    // code\n} catch (IOException e) {\n    System.err.println(\"IO Error: \" + e.getMessage());\n    // Handle appropriately\n}\n\n// Best: Custom exception handling\npublic void validateInput(String input) throws InvalidInputException {\n    if (input == null || input.isEmpty()) {\n        throw new InvalidInputException(\"Input cannot be empty\");\n    }\n}\n```\n\n### Documentation\n\n```java\n/**\n * Calculates the average of an array of numbers.\n * \n * @param numbers array of numbers\n * @return average value, or 0 if array is empty\n * @throws IllegalArgumentException if array contains non-positive values\n */\npublic static double calculateAverage(double[] numbers) {\n    if (numbers == null || numbers.length == 0) {\n        return 0;\n    }\n    double sum = 0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    return sum / numbers.length;\n}\n```\n\n---\n\n# INTERVIEW PREPARATION GUIDE\n\n## Common Interview Questions\n\n### Java Fundamentals\n\n**Q1: What are the differences between Stack and Heap memory?**\n\nA: Stack stores primitive values and object references, is thread-safe, throws StackOverflowException. Heap stores objects, is shared by threads, throws OutOfMemoryException. Stack is faster, Heap is larger.\n\n**Q2: Explain the difference between == and .equals()**\n\nA: `==` compares reference (memory address), `.equals()` compares content. For strings, use `.equals()` to compare actual content.\n\n**Q3: What is autoboxing and unboxing?**\n\nA: Autoboxing is automatic conversion of primitive to wrapper (int → Integer). Unboxing is automatic conversion of wrapper to primitive (Integer → int).\n\n### OOP Concepts\n\n**Q4: What are the 4 pillars of OOP?**\n\nA: \n1. **Encapsulation:** Bundling data with methods\n2. **Inheritance:** Acquiring properties from parent class\n3. **Polymorphism:** Many forms (method overriding/overloading)\n4. **Abstraction:** Showing essential features, hiding complexity\n\n**Q5: Can you override a static method?**\n\nA: No, static methods cannot be overridden. They can be hidden. Static belongs to class, not instance.\n\n### Collections\n\n**Q6: What's the difference between ArrayList and LinkedList?**\n\nA: ArrayList uses array (fast access O(1), slow insertion O(n)). LinkedList uses doubly-linked list (slow access O(n), fast insertion O(1)).\n\n**Q7: Why is HashMap not thread-safe?**\n\nA: HashMap allows null keys and values, doesn't synchronize access. Use ConcurrentHashMap or Collections.synchronizedMap() for thread safety.\n\n### Exception Handling\n\n**Q8: What's the difference between checked and unchecked exceptions?**\n\nA: Checked (IOException, SQLException) must be caught or declared. Unchecked (RuntimeException subclasses) are optional. Checked found at compile-time, unchecked at runtime.\n\n**Q9: Can finally block be skipped?**\n\nA: Yes, if: System.exit() called, thread dies, power failure, JVM crashes.\n\n### Multithreading\n\n**Q10: What's the difference between Runnable and Thread?**\n\nA: Thread is a class (extend for single inheritance), Runnable is interface (implement for multiple). Runnable is preferred because Java doesn't support multiple inheritance.\n\n---\n\n## Practice Problems with Solutions\n\n### Problem 1: Student Management System\n\n**Problem:** Create a system to manage students with their GPA and display top performers.\n\n**Solution:**\n```java\nimport java.util.*;\n\npublic class StudentManagementSystem {\n    static class Student implements Comparable<Student> {\n        String name;\n        int rollNo;\n        double gpa;\n        \n        public Student(String name, int rollNo, double gpa) {\n            this.name = name;\n            this.rollNo = rollNo;\n            this.gpa = Math.min(4.0, Math.max(0, gpa));\n        }\n        \n        @Override\n        public int compareTo(Student other) {\n            return Double.compare(other.gpa, this.gpa);  // Descending\n        }\n        \n        @Override\n        public String toString() {\n            return name + \" (Roll: \" + rollNo + \", GPA: \" + String.format(\"%.2f\", gpa) + \")\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>();\n        students.add(new Student(\"Alice\", 101, 3.9));\n        students.add(new Student(\"Bob\", 102, 3.5));\n        students.add(new Student(\"Charlie\", 103, 3.8));\n        students.add(new Student(\"Diana\", 104, 3.2));\n        \n        // Sort by GPA\n        Collections.sort(students);\n        \n        System.out.println(\"Top 2 Students:\");\n        for (int i = 0; i < Math.min(2, students.size()); i++) {\n            System.out.println(i + 1 + \". \" + students.get(i));\n        }\n    }\n}\n```\n\n### Problem 2: Bank Account with Thread Safety\n\n**Problem:** Create a bank account that can be safely accessed by multiple threads.\n\n**Solution:**\n```java\npublic class ThreadSafeBankAccount {\n    private int balance;\n    \n    public ThreadSafeBankAccount(int initialBalance) {\n        this.balance = initialBalance;\n    }\n    \n    public synchronized void deposit(int amount) {\n        balance += amount;\n        System.out.println(Thread.currentThread().getName() + \" deposited: \" + amount);\n    }\n    \n    public synchronized void withdraw(int amount) {\n        if (balance >= amount) {\n            balance -= amount;\n            System.out.println(Thread.currentThread().getName() + \" withdrew: \" + amount);\n        } else {\n            System.out.println(Thread.currentThread().getName() + \" insufficient funds\");\n        }\n    }\n    \n    public synchronized int getBalance() {\n        return balance;\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        ThreadSafeBankAccount account = new ThreadSafeBankAccount(1000);\n        \n        // Multiple threads accessing same account\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                account.withdraw(100);\n            }\n        }, \"Thread-1\");\n        \n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                account.deposit(100);\n            }\n        }, \"Thread-2\");\n        \n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        \n        System.out.println(\"Final balance: \" + account.getBalance());\n    }\n}\n```\n\n---\n\n## Performance Tips\n\n1. **Use ArrayList instead of Vector** (Vector is synchronized, slower)\n2. **Prefer StringBuilder for string concatenation** (String is immutable)\n3. **Use try-with-resources** for automatic resource closing\n4. **Cache frequently used objects** to avoid repeated creation\n5. **Use appropriate collection types** (HashSet for lookup, ArrayList for sequential)\n6. **Minimize exception handling** in loops\n7. **Use primitive arrays** for large numerical data\n8. **Profile before optimizing** - don't optimize prematurely\n\n---\n\n## Conclusion\n\nThis comprehensive guide covers Java from basic syntax to advanced concepts. Master each section thoroughly:\n\n1. **Start with Fundamentals** - Variables, operators, control flow\n2. **Move to OOP** - Classes, inheritance, polymorphism\n3. **Learn Collections** - ArrayList, Map, Set, Queue\n4. **Explore Advanced Topics** - Streams, threading, design patterns\n5. **Practice Daily** - Solve real-world problems\n6. **Review Interview Questions** - Prepare for technical interviews\n\nRemember: **Consistency is key**. Practice small programs daily rather than cramming. Good luck with your Java journey!\n\n---\n\n**Last Updated:** 2025\n**Java Version:** Java 8+\n**Difficulty:** Basic to Advanced"
        }
      ]
    },
    {
      "id": "dsa",
      "title": "Data Structures & Algorithms",
      "description": "Professional Java DSA training covering arrays, linked lists, trees, graphs, sorting, and searching algorithms.",
      "level": "Beginner to Advanced",
      "totalSections": 12,
      "estimatedHours": 35,
      "sections": [
        {
          "id": "1.1",
          "title": "Language Syntax & Control Structures",
          "part": "Part 1: Fundamentals",
          "content": "#### Concept Explanation\n\n**Why this matters:** Before diving into DSA, you need solid Java fundamentals. Think of Java syntax as the alphabet and control structures as grammar—without them, you can't communicate your algorithms effectively.\n\n**Key Concepts:**\n- Variables and Data Types\n- Control Flow (if-else, loops)\n- Functions/Methods\n- Object-Oriented Programming basics\n\n#### Key Takeaways to Remember\n\n**Memory Aid: \"VDF\"**\n- **V** = Variables (store data)\n- **D** = Data types (int, String, etc.)\n- **F** = Flow control (if, for, while)\n\nThese three pillars let you build any algorithm.\n\n#### Questions & Answers\n\n**Q1: What's the difference between while and for loops?**\n\nA: A **while loop** checks a condition first; a **for loop** is better when you know how many iterations. For loops are preferred in DSA because you often iterate over arrays of known size.\n\n```java\n// For loop - use this in DSA (cleaner for iterations)\nfor(int i = 0; i < n; i++) {\n    // process\n}\n\n// While loop - use when condition is complex\nwhile(pointer < array.length && array[pointer] > 0) {\n    pointer++;\n}\n```\n\n**Q2: What does pass-by-value mean in Java?**\n\nA: Java passes copies of primitive values. For objects (like arrays), it passes a copy of the reference, meaning the reference points to the same object in memory.\n\n```java\nint[] arr = {1, 2, 3};\nmodifyArray(arr); // Passes reference copy - original array IS modified\n// Inside function: arr[0] = 99 affects original array\n\nvoid modifyArray(int[] arr) {\n    arr[0] = 99;\n}\n```\n\n**Q3: Why is OOP important for DSA?**\n\nA: OOP lets you encapsulate data structures into reusable classes. You can create a Stack class that you'll reuse throughout your algorithms.\n\n#### Problems with Solutions\n\n**Problem 1.1: Count Occurrences of a Number**\n\n*Statement:* Given an array of integers, count how many times a specific number appears.\n\n*Approach:*\n1. Iterate through the array\n2. Compare each element with target\n3. Increment counter on match\n\n```java\npublic class OccurrenceCounter {\n    \n    public static int countOccurrences(int[] arr, int target) {\n        int count = 0;\n        for(int i = 0; i < arr.length; i++) {\n            if(arr[i] == target) {\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    // Test cases\n    public static void main(String[] args) {\n        // Test case 1: Multiple occurrences\n        assert countOccurrences(new int[]{1, 2, 2, 3, 2, 4}, 2) == 3 : \"Failed: TC1\";\n        \n        // Test case 2: No occurrences\n        assert countOccurrences(new int[]{1, 2, 3, 4}, 5) == 0 : \"Failed: TC2\";\n        \n        // Test case 3: All elements are target\n        assert countOccurrences(new int[]{5, 5, 5, 5}, 5) == 4 : \"Failed: TC3\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Analysis:**\n- **Time Complexity:** O(n) - single pass through array\n- **Space Complexity:** O(1) - only using a counter variable\n\n---\n\n**Problem 1.2: Find Maximum and Minimum in Array**\n\n*Statement:* Find both the maximum and minimum values in an array in a single pass.\n\n```java\npublic class MinMaxFinder {\n    \n    public static class Result {\n        int min;\n        int max;\n        Result(int min, int max) {\n            this.min = min;\n            this.max = max;\n        }\n    }\n    \n    public static Result findMinMax(int[] arr) {\n        if(arr.length == 0) return null;\n        \n        int min = arr[0];\n        int max = arr[0];\n        \n        for(int i = 1; i < arr.length; i++) {\n            if(arr[i] < min) min = arr[i];\n            if(arr[i] > max) max = arr[i];\n        }\n        \n        return new Result(min, max);\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Regular array\n        Result r1 = findMinMax(new int[]{3, 1, 4, 1, 5, 9, 2, 6});\n        assert r1.min == 1 && r1.max == 9 : \"Failed: TC1\";\n        \n        // Test case 2: All negative numbers\n        Result r2 = findMinMax(new int[]{-5, -2, -10, -1});\n        assert r2.min == -10 && r2.max == -1 : \"Failed: TC2\";\n        \n        // Test case 3: Single element\n        Result r3 = findMinMax(new int[]{42});\n        assert r3.min == 42 && r3.max == 42 : \"Failed: TC3\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Key Learning:** Finding both min and max in one pass is more efficient than two separate passes.\n\n---\n\n**Problem 1.3: Reverse an Array**\n\n*Statement:* Reverse an array in-place without using extra space.\n\n```java\npublic class ArrayReversal {\n    \n    public static void reverseArray(int[] arr) {\n        int left = 0, right = arr.length - 1;\n        \n        while(left < right) {\n            // Swap\n            int temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            \n            left++;\n            right--;\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Even length array\n        int[] arr1 = {1, 2, 3, 4};\n        reverseArray(arr1);\n        assert java.util.Arrays.equals(arr1, new int[]{4, 3, 2, 1}) : \"Failed: TC1\";\n        \n        // Test case 2: Odd length array\n        int[] arr2 = {1, 2, 3, 4, 5};\n        reverseArray(arr2);\n        assert java.util.Arrays.equals(arr2, new int[]{5, 4, 3, 2, 1}) : \"Failed: TC2\";\n        \n        // Test case 3: Single element\n        int[] arr3 = {42};\n        reverseArray(arr3);\n        assert java.util.Arrays.equals(arr3, new int[]{42}) : \"Failed: TC3\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Key Insight:** Two-pointer technique is fundamental in DSA. Remember it!\n\n---"
        },
        {
          "id": "2.1",
          "title": "Introduction to Data Structures",
          "part": "Part 2: Data Structures",
          "content": "#### Concept Explanation\n\n**What is a Data Structure?**\n\nA data structure is an organized way to store, access, and modify data. It's like choosing between different ways to organize books in a library:\n- **Array shelf:** Quick access by position, but finding a specific book takes time\n- **Alphabetical catalog:** Slower by position, but finding specific books is faster\n\n**Why Data Structures Matter:**\n\nDifferent data structures excel at different operations:\n- Need fast lookup? Use **Hash Tables**\n- Need LIFO access? Use **Stacks**\n- Need FIFO access? Use **Queues**\n- Need hierarchical data? Use **Trees**\n\n**Memory Aid: \"SPEED vs ORGANIZATION\"**\n\nEvery data structure trades off between:\n- **Speed** of different operations\n- **Organization** of data in memory\n- **Space** usage\n\n#### Key Takeaways to Remember\n\nThink of each data structure as a tool:\n- **Array** = Toolbox shelf (fast access by index, hard to insert/delete)\n- **Linked List** = Chain (easy to insert/delete, slow access)\n- **Stack** = Stack of plates (last one added = first one removed)\n- **Queue** = Line at bank (first one = first out)\n- **Hash Table** = Dictionary (word → definition instant lookup)\n\n#### Questions & Answers\n\n**Q1: What's the main difference between Array and Linked List?**\n\nA:\n| Operation | Array | Linked List |\n|-----------|-------|-------------|\n| Access by index | O(1) | O(n) |\n| Insert/Delete at end | O(1) amortized | O(n) to find, O(1) to insert |\n| Insert/Delete at beginning | O(n) | O(1) |\n| Space | Contiguous | Non-contiguous |\n\n**Q2: When would you use a Linked List instead of Array?**\n\nA: When you need:\n- Frequent insertions/deletions at beginning or middle\n- Dynamic size without pre-allocation\n- No random access needed\n\n**Q3: What is the difference between static and dynamic data structures?**\n\nA: \n- **Static (Array):** Fixed size at compile time, contiguous memory\n- **Dynamic (Linked List, ArrayList):** Size grows/shrinks at runtime\n\n---"
        },
        {
          "id": "3.1",
          "title": "Time Complexity",
          "part": "Part 3: Complexity Analysis",
          "content": "#### Concept Explanation\n\n**What is Time Complexity?**\n\nTime complexity measures how the number of operations grows as input size increases. It tells you: \"If input doubles, how much slower is my algorithm?\"\n\n**Why This Matters:**\n\nAn algorithm with O(n²) on 1000 elements takes 1,000,000 operations.  \nThe same algorithm on 10,000 elements takes 100,000,000 operations.  \nThat's the difference between instant and slow!\n\n**Memory Aid: \"LESS STEPS = FASTER CODE\"**\n\nAlways aim for algorithms with lower complexity.\n\n#### Common Runtimes Explained\n\n**1. O(1) - Constant Time**\n```java\npublic int getFirst(int[] arr) {\n    return arr[0]; // Always 1 operation, regardless of array size\n}\n```\n*Examples:* Hash table lookup, Array access by index\n\n**2. O(log n) - Logarithmic Time**\n```java\npublic int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(arr[mid] == target) return mid;\n        if(arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1; // Each step eliminates half the elements\n}\n```\n*Why it's fast:* Each step eliminates half the search space. For 1 million elements, maximum 20 steps!\n\n**3. O(n) - Linear Time**\n```java\npublic int findMax(int[] arr) {\n    int max = arr[0];\n    for(int i = 1; i < arr.length; i++) { // Single loop through all elements\n        max = Math.max(max, arr[i]);\n    }\n    return max;\n}\n```\n*Examples:* Linear search, traversing entire array\n\n**4. O(n log n) - Linearithmic Time**\n```java\n// Merge Sort - divide input in half, then merge\n// This is the standard for efficient sorting\n```\n*Examples:* Merge Sort, Quick Sort, Heap Sort\n\n**5. O(n²) - Quadratic Time**\n```java\npublic void bubbleSort(int[] arr) {\n    for(int i = 0; i < arr.length; i++) {        // Outer loop: n times\n        for(int j = 0; j < arr.length - i - 1; j++) { // Inner loop: n times\n            if(arr[j] > arr[j + 1]) {\n                // Swap - this runs roughly n*n times\n            }\n        }\n    }\n}\n```\n*Problem:* Gets extremely slow for large inputs\n\n**6. O(2^n) - Exponential Time**\n```java\n// Fibonacci with recursion (inefficient)\npublic int fib(int n) {\n    if(n <= 1) return n;\n    return fib(n-1) + fib(n-2); // Explores 2^n branches\n}\n```\n*Problem:* This is VERY slow. Avoid if possible!\n\n#### Complexity Comparison Chart\n\n```\nOperations needed for different complexities:\n\nn = 10:\n  O(1)    : 1\n  O(log n): 3\n  O(n)    : 10\n  O(n log n): 30\n  O(n²)   : 100\n  O(2^n)  : 1024\n\nn = 100:\n  O(1)    : 1\n  O(log n): 7\n  O(n)    : 100\n  O(n log n): 700\n  O(n²)   : 10,000\n  O(2^n)  : TOO BIG (1.26 × 10^30)\n\nn = 1000:\n  O(1)    : 1\n  O(log n): 10\n  O(n)    : 1,000\n  O(n log n): 10,000\n  O(n²)   : 1,000,000\n  O(2^n)  : IMPOSSIBLE\n```\n\n#### How to Calculate Complexity\n\n**Step 1: Count the loops**\n```java\nfor(int i = 0; i < n; i++) {           // This runs n times\n    for(int j = 0; j < n; j++) {       // This runs n times for each i\n        x++;                            // This is O(1)\n    }\n}\n// Total: n × n × 1 = O(n²)\n```\n\n**Step 2: Ignore constants**\n```java\n// O(3n + 5) simplifies to O(n)\nfor(int i = 0; i < 3*n; i++) x++;      // Multiply loops by 3\nfor(int i = 0; i < 5; i++) x++;        // Fixed loop\n// We drop constants: O(3n + 5) → O(n)\n```\n\n**Step 3: Keep dominant term**\n```java\n// O(n² + n) simplifies to O(n²)\nfor(int i = 0; i < n; i++) {           // n² iterations\n    for(int j = 0; j < n; j++) x++;\n}\nfor(int i = 0; i < n; i++) x++;        // n iterations\n// n² dominates n: O(n² + n) → O(n²)\n```\n\n#### Big-O Notation Explained\n\n**What is Big-O?**\n\nBig-O describes the **worst-case** scenario. It's the upper bound on how slow your algorithm can get.\n\n**Other Notations:**\n\n- **Big-O (O):** Worst case (upper bound)\n- **Big-Omega (Ω):** Best case (lower bound)  \n- **Big-Theta (Θ):** Average case (tight bound)\n\n*In practice, we usually only care about Big-O.*\n\n#### Questions & Answers\n\n**Q1: Why do we use Big-O instead of actual time?**\n\nA: Actual time depends on hardware, language, implementation. Big-O is universal and focuses on what matters: how the algorithm scales.\n\n**Q2: I have two algorithms: O(n) and O(n log n). Which is faster?**\n\nA: **O(n) is faster** at scale. But for small n, both might be equally fast. O(log n) is the fastest possible if you need to examine the data.\n\n**Q3: What's the difference between Space Complexity and Time Complexity?**\n\nA:\n- **Time Complexity:** How many operations (speed)\n- **Space Complexity:** How much extra memory (not counting input)\n\n```java\n// O(n) space - we create new array\nint[] doubleArray(int[] arr) {\n    int[] result = new int[arr.length];  // Extra O(n) space\n    for(int i = 0; i < arr.length; i++) {\n        result[i] = arr[i] * 2;\n    }\n    return result;\n}\n\n// O(1) space - no extra space\nvoid doubleInPlace(int[] arr) {\n    for(int i = 0; i < arr.length; i++) {\n        arr[i] = arr[i] * 2;  // Just 1 counter variable\n    }\n}\n```\n\n#### Problems with Solutions\n\n**Problem 3.1: Analyze Complexity of Code**\n\n*Statement:* What is the time and space complexity?\n\n```java\npublic class ComplexityAnalysis {\n    \n    // Method to analyze\n    public static int sumOfElements(int[] arr) {\n        int sum = 0;\n        for(int i = 0; i < arr.length; i++) {\n            sum += arr[i];\n        }\n        return sum;\n    }\n}\n```\n\n**Solution:**\n- **Time:** O(n) - loop runs n times\n- **Space:** O(1) - only using `sum` variable\n\n**Test cases:**\n```java\npublic static void main(String[] args) {\n    // Test case 1: Regular array\n    assert sumOfElements(new int[]{1, 2, 3, 4, 5}) == 15 : \"TC1 failed\";\n    \n    // Test case 2: Single element\n    assert sumOfElements(new int[]{42}) == 42 : \"TC2 failed\";\n    \n    // Test case 3: Zeros\n    assert sumOfElements(new int[]{0, 0, 0}) == 0 : \"TC3 failed\";\n    \n    System.out.println(\"✓ Complexity analysis correct!\");\n}\n```\n\n---\n\n**Problem 3.2: Compare Two Algorithms**\n\n*Statement:* Which algorithm is better?\n\n```java\n// Algorithm 1: Nested loops\npublic static void algorithm1(int n) {\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            System.out.println(i + \",\" + j);\n        }\n    }\n}\n\n// Algorithm 2: Optimized\npublic static void algorithm2(int n) {\n    for(int i = 0; i < n; i++) {\n        System.out.println(i);\n    }\n}\n```\n\n**Answer:** Algorithm 2 is better!\n- Algorithm 1: **O(n²)**\n- Algorithm 2: **O(n)**\n\nFor n=1000: Alg1 = 1,000,000 ops, Alg2 = 1,000 ops. That's 1000x faster!\n\n---\n\n**Problem 3.3: Find Optimal Algorithm**\n\n*Statement:* You need to find if a number exists in a **sorted** array. Choose the best algorithm.\n\n```java\n// Option A: Linear Search - O(n)\npublic static boolean linearSearch(int[] arr, int target) {\n    for(int i = 0; i < arr.length; i++) {\n        if(arr[i] == target) return true;\n    }\n    return false;\n}\n\n// Option B: Binary Search - O(log n)\npublic static boolean binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(arr[mid] == target) return true;\n        if(arr[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return false;\n}\n```\n\n**Test cases:**\n```java\npublic static void main(String[] args) {\n    int[] arr = {1, 3, 5, 7, 9, 11, 13};\n    \n    // Test case 1: Element exists\n    assert binarySearch(arr, 7) == true : \"TC1 failed\";\n    \n    // Test case 2: Element doesn't exist\n    assert binarySearch(arr, 8) == false : \"TC2 failed\";\n    \n    // Test case 3: First element\n    assert binarySearch(arr, 1) == true : \"TC3 failed\";\n    \n    System.out.println(\"✓ Binary Search is O(log n) - much faster!\");\n}\n```\n\n**Answer:** Use **Binary Search (Option B)**!\n- For sorted array with 1 million elements:\n  - Linear: ~500,000 ops average\n  - Binary: ~20 ops\n\n---"
        },
        {
          "id": "4.1",
          "title": "Arrays",
          "part": "Part 4: Basic Data Structures",
          "content": "#### Concept Explanation\n\n**What is an Array?**\n\nAn array is a collection of elements stored in **contiguous memory locations**. Think of it as a row of mailboxes, each with an index number.\n\n```\nArray: [10, 20, 30, 40, 50]\nIndex:  0   1   2   3   4\n```\n\n**Why Arrays Matter:**\n\n- **Fastest access** by index O(1)\n- **Memory efficient** - no extra pointers\n- **Foundation** for many other data structures\n\n**Memory Aid: \"INDEX TO VALUE IN ONE STEP\"**\n\nArray access is O(1) because memory is contiguous. Just calculate position = base + index * size.\n\n#### Key Concepts\n\n**1. Declaration and Initialization**\n```java\n// Declaration\nint[] numbers;\nint[] numbers = new int[5];\n\n// Initialization with values\nint[] scores = {85, 90, 78, 92};\n```\n\n**2. Accessing Elements**\n```java\nint first = scores[0];    // Access - O(1)\nscores[2] = 88;           // Modify - O(1)\n```\n\n**3. Array Length**\n```java\nint size = scores.length;  // Get length - O(1)\n```\n\n**4. 2D Arrays**\n```java\nint[][] matrix = new int[3][3];  // 3x3 matrix\nmatrix[0][0] = 1;                 // Access element\n```\n\n#### Questions & Answers\n\n**Q1: Why can't we resize arrays?**\n\nA: Arrays have fixed size in Java. The memory block is allocated once. To grow, you need a new larger array and copy elements (O(n) operation).\n\nThis is why `ArrayList` exists - it automatically grows!\n\n**Q2: What's the difference between Array and ArrayList?**\n\nA:\n| Feature | Array | ArrayList |\n|---------|-------|-----------|\n| Size | Fixed | Dynamic |\n| Resizing | Manual copy | Automatic |\n| Primitives | Support int, double | Only objects |\n| Speed | Slightly faster | Slight overhead |\n\n**Q3: What happens when you pass an array to a function?**\n\nA: The reference is passed (reference copy), so modifications affect the original:\n\n```java\nvoid modify(int[] arr) {\n    arr[0] = 99;  // This WILL modify original array\n}\n\nint[] myArray = {1, 2, 3};\nmodify(myArray);\n// myArray is now {99, 2, 3}\n```\n\n#### Problems with Solutions\n\n**Problem 4.1: Rotate Array**\n\n*Statement:* Rotate an array to the right by k positions.\n\nExample: [1,2,3,4,5] rotated by 2 = [4,5,1,2,3]\n\n```java\npublic class ArrayRotation {\n    \n    public static void rotateArray(int[] arr, int k) {\n        if(arr.length == 0) return;\n        k = k % arr.length;  // Handle k > array length\n        \n        // Reverse entire array\n        reverse(arr, 0, arr.length - 1);\n        // Reverse first k elements\n        reverse(arr, 0, k - 1);\n        // Reverse remaining elements\n        reverse(arr, k, arr.length - 1);\n    }\n    \n    private static void reverse(int[] arr, int start, int end) {\n        while(start < end) {\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Normal rotation\n        int[] arr1 = {1, 2, 3, 4, 5};\n        rotateArray(arr1, 2);\n        assert java.util.Arrays.equals(arr1, new int[]{4, 5, 1, 2, 3}) : \"TC1 failed\";\n        \n        // Test case 2: k = 0 (no rotation)\n        int[] arr2 = {1, 2, 3};\n        rotateArray(arr2, 0);\n        assert java.util.Arrays.equals(arr2, new int[]{1, 2, 3}) : \"TC2 failed\";\n        \n        // Test case 3: k > array length\n        int[] arr3 = {1, 2, 3};\n        rotateArray(arr3, 5);  // Same as rotating by 2\n        assert java.util.Arrays.equals(arr3, new int[]{2, 3, 1}) : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - 3 reverse operations, each O(n)\n- **Space:** O(1) - in-place manipulation\n\n**Key Insight:** Three reversals is genius! First reverse all, then reverse halves separately.\n\n---\n\n**Problem 4.2: Find All Pairs with Sum**\n\n*Statement:* Find all pairs of elements that sum to a target value.\n\nExample: [2, 7, 11, 15], target=9 → [[2,7]]\n\n```java\nimport java.util.*;\n\npublic class PairSum {\n    \n    public static List<int[]> findPairs(int[] arr, int target) {\n        List<int[]> result = new ArrayList<>();\n        Set<Integer> seen = new HashSet<>();\n        Set<String> pairs = new HashSet<>();  // To avoid duplicates\n        \n        for(int num : arr) {\n            int complement = target - num;\n            \n            if(seen.contains(complement)) {\n                // Found a pair - store in sorted order to avoid duplicates\n                int[] pair = {Math.min(num, complement), Math.max(num, complement)};\n                String pairKey = pair[0] + \",\" + pair[1];\n                if(!pairs.contains(pairKey)) {\n                    pairs.add(pairKey);\n                    result.add(pair);\n                }\n            }\n            seen.add(num);\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Multiple pairs\n        int[] arr1 = {2, 7, 11, 15, 6, 3};\n        List<int[]> pairs1 = findPairs(arr1, 9);\n        assert pairs1.size() == 2 : \"TC1: Expected 2 pairs\";\n        \n        // Test case 2: No pairs\n        int[] arr2 = {1, 2, 3};\n        List<int[]> pairs2 = findPairs(arr2, 10);\n        assert pairs2.size() == 0 : \"TC2: Expected 0 pairs\";\n        \n        // Test case 3: Duplicate elements\n        int[] arr3 = {1, 1, 1, 1};\n        List<int[]> pairs3 = findPairs(arr3, 2);\n        assert pairs3.size() == 1 : \"TC3: Expected 1 unique pair\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - single pass through array\n- **Space:** O(n) - HashSet stores seen elements\n\n---\n\n**Problem 4.3: Merge Two Sorted Arrays**\n\n*Statement:* Merge two sorted arrays into one sorted array.\n\nExample: [1,3,5] + [2,4,6] = [1,2,3,4,5,6]\n\n```java\npublic class MergeSortedArrays {\n    \n    public static int[] merge(int[] arr1, int[] arr2) {\n        int[] result = new int[arr1.length + arr2.length];\n        int i = 0, j = 0, k = 0;\n        \n        // Compare and place smaller element\n        while(i < arr1.length && j < arr2.length) {\n            if(arr1[i] <= arr2[j]) {\n                result[k++] = arr1[i++];\n            } else {\n                result[k++] = arr2[j++];\n            }\n        }\n        \n        // Copy remaining elements from arr1\n        while(i < arr1.length) {\n            result[k++] = arr1[i++];\n        }\n        \n        // Copy remaining elements from arr2\n        while(j < arr2.length) {\n            result[k++] = arr2[j++];\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Both arrays have elements\n        int[] r1 = merge(new int[]{1, 3, 5}, new int[]{2, 4, 6});\n        assert java.util.Arrays.equals(r1, new int[]{1, 2, 3, 4, 5, 6}) : \"TC1 failed\";\n        \n        // Test case 2: First array is empty\n        int[] r2 = merge(new int[]{}, new int[]{1, 2, 3});\n        assert java.util.Arrays.equals(r2, new int[]{1, 2, 3}) : \"TC2 failed\";\n        \n        // Test case 3: Duplicate elements\n        int[] r3 = merge(new int[]{1, 2, 2}, new int[]{2, 3});\n        assert java.util.Arrays.equals(r3, new int[]{1, 2, 2, 2, 3}) : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n + m) - visit each element once\n- **Space:** O(n + m) - result array\n\n**Key Insight:** This is the merge step in Merge Sort! Very efficient.\n\n---"
        },
        {
          "id": "4.2",
          "title": "Linked Lists",
          "part": "Part 4: Basic Data Structures",
          "content": "#### Concept Explanation\n\n**What is a Linked List?**\n\nA linked list is a linear collection where each element (node) contains:\n1. **Data** - the actual value\n2. **Next pointer** - reference to the next node\n\n```\nLinked List: 10 → 20 → 30 → 40 → null\n                ↓      ↓      ↓      ↓\n             Node1   Node2  Node3  Node4\n```\n\nUnlike arrays (contiguous memory), linked list nodes can be anywhere in memory!\n\n**Memory Aid: \"CHAIN OF REFERENCES\"**\n\nThink of it like a chain:\n- Array = Direct path from start to end\n- Linked List = Follow pointers link by link\n\n**Why Linked Lists?**\n\n- **Efficient insertions/deletions** at known position (O(1))\n- **No size limit** - grow dynamically\n- **No shifting needed** when inserting/deleting middle\n\n**Trade-offs:**\n- Access by index is **O(n)** instead of O(1)\n- Extra **memory for pointers**\n\n#### Key Concepts\n\n**1. Node Definition**\n```java\npublic class Node {\n    int data;\n    Node next;\n    \n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n```\n\n**2. Linked List Class**\n```java\npublic class LinkedList {\n    Node head;\n    \n    LinkedList() {\n        head = null;\n    }\n    \n    // Insert at beginning - O(1)\n    public void insertAtBeginning(int data) {\n        Node newNode = new Node(data);\n        newNode.next = head;\n        head = newNode;\n    }\n    \n    // Insert at end - O(n)\n    public void insertAtEnd(int data) {\n        Node newNode = new Node(data);\n        if(head == null) {\n            head = newNode;\n            return;\n        }\n        Node current = head;\n        while(current.next != null) {\n            current = current.next;\n        }\n        current.next = newNode;\n    }\n}\n```\n\n#### Questions & Answers\n\n**Q1: When do you use Linked List over Array?**\n\nA: Use Linked List when:\n- Frequent insertions/deletions at beginning\n- Size unpredictable\n- Don't need random access\n- Memory is fragmented\n\n**Q2: What's the complexity of searching in Linked List?**\n\nA: **O(n)** - must traverse from head. There's no shortcut!\n\nThis is why arrays are better for searching.\n\n**Q3: What's a \"circular\" linked list?**\n\nA: The last node's next pointer points back to the first node, creating a circle:\n\n```\nCircular: 10 → 20 → 30 → (back to 10)\n```\n\nUseful for applications like round-robin scheduling.\n\n#### Problems with Solutions\n\n**Problem 4.4: Reverse a Linked List**\n\n*Statement:* Reverse the entire linked list.\n\nExample: 1→2→3→4 becomes 4→3→2→1\n\n```java\npublic class LinkedListReversal {\n    \n    public static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    \n    public static Node reverseList(Node head) {\n        Node prev = null;\n        Node current = head;\n        Node next = null;\n        \n        while(current != null) {\n            next = current.next;      // Save next node\n            current.next = prev;       // Reverse the link\n            prev = current;            // Move prev forward\n            current = next;            // Move current forward\n        }\n        \n        return prev;  // New head\n    }\n    \n    public static void printList(Node head) {\n        while(head != null) {\n            System.out.print(head.data + \" → \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Regular list\n        Node head1 = new Node(1);\n        head1.next = new Node(2);\n        head1.next.next = new Node(3);\n        head1.next.next.next = new Node(4);\n        \n        Node reversed1 = reverseList(head1);\n        // Should be: 4→3→2→1\n        assert reversed1.data == 4 : \"TC1 failed\";\n        assert reversed1.next.data == 3 : \"TC1 failed\";\n        \n        // Test case 2: Single node\n        Node head2 = new Node(42);\n        Node reversed2 = reverseList(head2);\n        assert reversed2.data == 42 : \"TC2 failed\";\n        assert reversed2.next == null : \"TC2 failed\";\n        \n        // Test case 3: Two nodes\n        Node head3 = new Node(1);\n        head3.next = new Node(2);\n        Node reversed3 = reverseList(head3);\n        assert reversed3.data == 2 && reversed3.next.data == 1 : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - visit each node once\n- **Space:** O(1) - only pointers, no extra space\n\n**Key Insight:** Use three pointers to track prev, current, next. This is a common pattern!\n\n---\n\n**Problem 4.5: Detect Cycle in Linked List**\n\n*Statement:* Detect if linked list has a cycle (node pointing back).\n\n```java\npublic class CycleDetection {\n    \n    public static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    \n    // Floyd's Cycle Detection Algorithm (Tortoise & Hare)\n    public static boolean hasCycle(Node head) {\n        Node slow = head;\n        Node fast = head;\n        \n        while(fast != null && fast.next != null) {\n            slow = slow.next;           // Move 1 step\n            fast = fast.next.next;      // Move 2 steps\n            \n            if(slow == fast) {          // They meet = cycle exists\n                return true;\n            }\n        }\n        \n        return false;  // Fast reached end = no cycle\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: List with cycle\n        Node head1 = new Node(1);\n        Node node2 = new Node(2);\n        Node node3 = new Node(3);\n        head1.next = node2;\n        node2.next = node3;\n        node3.next = node2;  // Creates cycle: 2→3→2\n        \n        assert hasCycle(head1) == true : \"TC1 failed\";\n        \n        // Test case 2: No cycle\n        Node head2 = new Node(1);\n        head2.next = new Node(2);\n        head2.next.next = new Node(3);\n        \n        assert hasCycle(head2) == false : \"TC2 failed\";\n        \n        // Test case 3: Single node cycle\n        Node head3 = new Node(1);\n        head3.next = head3;  // Points to itself\n        \n        assert hasCycle(head3) == true : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - tortoise and hare meet in linear time\n- **Space:** O(1) - no extra space, just two pointers\n\n**Key Insight:** Floyd's algorithm is brilliant! Two pointers moving at different speeds will always meet if there's a cycle.\n\n---\n\n**Problem 4.6: Find Middle of Linked List**\n\n*Statement:* Find the middle node of a linked list.\n\nExample: 1→2→3→4→5 → middle is 3\n\n```java\npublic class LinkedListMiddle {\n    \n    public static class Node {\n        int data;\n        Node next;\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    \n    public static Node findMiddle(Node head) {\n        if(head == null) return null;\n        \n        Node slow = head;\n        Node fast = head;\n        \n        // Move slow 1 step, fast 2 steps\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        return slow;  // Slow is at middle\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Odd number of nodes\n        Node head1 = new Node(1);\n        head1.next = new Node(2);\n        head1.next.next = new Node(3);\n        head1.next.next.next = new Node(4);\n        head1.next.next.next.next = new Node(5);\n        \n        Node middle1 = findMiddle(head1);\n        assert middle1.data == 3 : \"TC1 failed\";\n        \n        // Test case 2: Even number of nodes\n        Node head2 = new Node(1);\n        head2.next = new Node(2);\n        head2.next.next = new Node(3);\n        head2.next.next.next = new Node(4);\n        \n        Node middle2 = findMiddle(head2);\n        assert middle2.data == 3 : \"TC2 failed\";  // Returns first of two middles\n        \n        // Test case 3: Single node\n        Node head3 = new Node(42);\n        Node middle3 = findMiddle(head3);\n        assert middle3.data == 42 : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - traverse list once\n- **Space:** O(1) - just two pointers\n\n**Key Pattern:** Slow and fast pointer technique is powerful in linked lists!\n\n---"
        },
        {
          "id": "4.3",
          "title": "Stacks",
          "part": "Part 4: Basic Data Structures",
          "content": "#### Concept Explanation\n\n**What is a Stack?**\n\nA stack is a **Last-In-First-Out (LIFO)** data structure. The last item added is the first one removed.\n\nThink of a stack of plates:\n- You put plates on top\n- You take the top plate first\n- The last plate you put is the first you take\n\n```\nPush: [1, 2, 3]  ← 3 is on top\nPop:  []         ← Remove 3 first\n```\n\n**Why Stacks Matter:**\n\n- **Function calls** - call stack\n- **Undo functionality** - browser back button\n- **Expression evaluation** - parenthesis matching\n- **Backtracking** - DFS algorithm\n\n**Memory Aid: \"LIFO - LAST IN FIRST OUT\"**\n\nImagine a parking lot with one entrance/exit. The last car in must be the first car out!\n\n#### Key Concepts\n\n**1. Stack Implementation using Array**\n```java\npublic class Stack {\n    int[] arr;\n    int top = -1;\n    \n    public void push(int value) {\n        arr[++top] = value;\n    }\n    \n    public int pop() {\n        if(isEmpty()) throw new RuntimeException(\"Stack empty\");\n        return arr[top--];\n    }\n    \n    public int peek() {\n        if(isEmpty()) throw new RuntimeException(\"Stack empty\");\n        return arr[top];\n    }\n    \n    public boolean isEmpty() {\n        return top == -1;\n    }\n}\n```\n\n**2. Stack Implementation using LinkedList**\n```java\npublic class LinkedListStack {\n    private Node head;\n    \n    public void push(int data) {\n        Node newNode = new Node(data);\n        newNode.next = head;\n        head = newNode;\n    }\n    \n    public int pop() {\n        if(head == null) throw new RuntimeException(\"Stack empty\");\n        int data = head.data;\n        head = head.next;\n        return data;\n    }\n}\n```\n\n#### Questions & Answers\n\n**Q1: What's the difference between Stack and Queue?**\n\nA:\n| Operation | Stack | Queue |\n|-----------|-------|-------|\n| Remove from | Top (LIFO) | Front (FIFO) |\n| Use case | Undo, backtracking | Scheduling, BFS |\n| Example | Browser back | Print queue |\n\n**Q2: What operations should a Stack support?**\n\nA: Core operations (all O(1)):\n- **push(value)** - add element to top\n- **pop()** - remove and return top element\n- **peek()** - view top without removing\n- **isEmpty()** - check if empty\n\n**Q3: Can I use Java's built-in Stack?**\n\nA: Yes! `Stack<Integer> stack = new Stack<>();` But understanding implementation is important for interviews.\n\n#### Problems with Solutions\n\n**Problem 4.7: Valid Parentheses**\n\n*Statement:* Check if parentheses are balanced.\n\nExample: \"((()))\" → true, \"(()\" → false\n\n```java\nimport java.util.*;\n\npublic class ValidParentheses {\n    \n    public static boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        \n        for(char c : s.toCharArray()) {\n            if(c == '(' || c == '{' || c == '[') {\n                stack.push(c);  // Push opening bracket\n            } else {\n                if(stack.isEmpty()) return false;\n                \n                char opening = stack.pop();\n                // Check if brackets match\n                if((c == ')' && opening != '(') ||\n                   (c == '}' && opening != '{') ||\n                   (c == ']' && opening != '[')) {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();  // All brackets matched\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Valid balanced\n        assert isValid(\"()\") == true : \"TC1 failed\";\n        \n        // Test case 2: Valid mixed\n        assert isValid(\"([{}])\") == true : \"TC2 failed\";\n        \n        // Test case 3: Invalid - extra closing\n        assert isValid(\"())\") == false : \"TC3 failed\";\n        \n        // Test case 4: Invalid - mismatched\n        assert isValid(\"(]\") == false : \"TC4 failed\";\n        \n        // Test case 5: Empty string\n        assert isValid(\"\") == true : \"TC5 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - check each character once\n- **Space:** O(n) - worst case all opening brackets\n\n**Key Insight:** Stack is perfect for matching problems! Push opening, pop and match closing.\n\n---\n\n**Problem 4.8: Next Greater Element**\n\n*Statement:* For each element, find the next greater element in the array.\n\nExample: [1, 5, 0, 3, 4, 5] → [5, -1, 3, 4, 5, -1]\n\n```java\nimport java.util.*;\n\npublic class NextGreaterElement {\n    \n    public static int[] nextGreaterElement(int[] arr) {\n        int n = arr.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();  // Store indices\n        \n        // Traverse from right to left\n        for(int i = n - 1; i >= 0; i--) {\n            // Pop all smaller elements\n            while(!stack.isEmpty() && arr[stack.peek()] <= arr[i]) {\n                stack.pop();\n            }\n            \n            // If stack empty, no greater element\n            result[i] = stack.isEmpty() ? -1 : arr[stack.peek()];\n            \n            // Push current index\n            stack.push(i);\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Regular array\n        int[] r1 = nextGreaterElement(new int[]{1, 5, 0, 3, 4, 5});\n        assert java.util.Arrays.equals(r1, new int[]{5, -1, 3, 4, 5, -1}) : \"TC1 failed\";\n        \n        // Test case 2: No greater elements\n        int[] r2 = nextGreaterElement(new int[]{3, 2, 1});\n        assert java.util.Arrays.equals(r2, new int[]{-1, -1, -1}) : \"TC2 failed\";\n        \n        // Test case 3: All increasing\n        int[] r3 = nextGreaterElement(new int[]{1, 2, 3, 4});\n        int[] expected3 = {2, 3, 4, -1};\n        assert java.util.Arrays.equals(r3, expected3) : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - each element pushed and popped once\n- **Space:** O(n) - result array and stack\n\n**Key Insight:** Clever use of stack allows O(n) solution! Compare in reverse order.\n\n---\n\n**Problem 4.9: Evaluate Postfix Expression**\n\n*Statement:* Evaluate mathematical expression in postfix notation.\n\nExample: \"5 3 +\" → 8, \"10 5 / 2 +\" → 4\n\n```java\nimport java.util.*;\n\npublic class PostfixEvaluation {\n    \n    public static int evaluatePostfix(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        \n        for(String token : tokens) {\n            // If operator, pop two operands and calculate\n            if(token.equals(\"+\") || token.equals(\"-\") || \n               token.equals(\"*\") || token.equals(\"/\")) {\n                int b = stack.pop();  // Second operand\n                int a = stack.pop();  // First operand\n                int result = 0;\n                \n                if(token.equals(\"+\")) result = a + b;\n                else if(token.equals(\"-\")) result = a - b;\n                else if(token.equals(\"*\")) result = a * b;\n                else if(token.equals(\"/\")) result = a / b;\n                \n                stack.push(result);\n            } else {\n                // It's a number\n                stack.push(Integer.parseInt(token));\n            }\n        }\n        \n        return stack.pop();  // Final result\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Addition\n        assert evaluatePostfix(new String[]{\"5\", \"3\", \"+\"}) == 8 : \"TC1 failed\";\n        \n        // Test case 2: Mixed operations\n        assert evaluatePostfix(new String[]{\"10\", \"5\", \"/\", \"2\", \"+\"}) == 4 : \"TC2 failed\";\n        \n        // Test case 3: Complex expression\n        assert evaluatePostfix(new String[]{\"2\", \"3\", \"*\", \"4\", \"+\"}) == 10 : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - process each token once\n- **Space:** O(n) - stack size grows with expression\n\n**Key Insight:** Postfix notation is easy with stacks! No precedence or parentheses needed.\n\n---"
        },
        {
          "id": "4.4",
          "title": "Queues",
          "part": "Part 4: Basic Data Structures",
          "content": "#### Concept Explanation\n\n**What is a Queue?**\n\nA queue is a **First-In-First-Out (FIFO)** data structure. The first item added is the first one removed.\n\nThink of a queue at a bank:\n- First person in line is served first\n- New people join the back\n- People leave from the front\n\n```\nEnqueue: [1] → [1, 2] → [1, 2, 3]\nDequeue: [2, 3] → [3] → []\n```\n\n**Why Queues Matter:**\n\n- **Task scheduling** - process jobs in order\n- **BFS algorithm** - explore level by level\n- **Printer queue** - print jobs in order\n- **Message handling** - process messages sequentially\n\n**Memory Aid: \"FIFO - FIRST IN FIRST OUT\"**\n\nLike a real queue at a coffee shop. First customer pays first!\n\n#### Key Concepts\n\n**1. Queue Implementation using Array**\n```java\npublic class Queue {\n    int[] arr;\n    int front = 0, rear = -1;\n    \n    public void enqueue(int value) {\n        arr[++rear] = value;\n    }\n    \n    public int dequeue() {\n        if(isEmpty()) throw new RuntimeException(\"Queue empty\");\n        return arr[front++];\n    }\n    \n    public boolean isEmpty() {\n        return front > rear;\n    }\n}\n```\n\n**2. Circular Queue (efficient)**\n```java\npublic class CircularQueue {\n    int[] arr;\n    int front = -1, rear = -1, size;\n    \n    public void enqueue(int value) {\n        if(isFull()) throw new RuntimeException(\"Queue full\");\n        rear = (rear + 1) % size;\n        arr[rear] = value;\n        if(front == -1) front = 0;\n    }\n    \n    public int dequeue() {\n        if(isEmpty()) throw new RuntimeException(\"Queue empty\");\n        int data = arr[front];\n        front = (front + 1) % size;\n        if(front > rear) front = -1;\n        return data;\n    }\n}\n```\n\n#### Questions & Answers\n\n**Q1: Why use Circular Queue?**\n\nA: Regular queue wastes space. After dequeuing, front indices are unused.\n\nCircular queue reuses that space by wrapping around:\n```\nLinear:    [-, -, 3, 4, 5]  ← Wasted space at front\nCircular:  [5, 3, 4, 5, -]  ← Reuses space via modulo\n```\n\n**Q2: How do you implement Queue using Stack?**\n\nA: Use two stacks:\n- Stack 1: For enqueue\n- Stack 2: For dequeue (reversed)\n\nThis is clever but less efficient.\n\n#### Problems with Solutions\n\n**Problem 4.10: Implement Queue using Stack**\n\n*Statement:* Implement Queue using only Stack operations.\n\n```java\nimport java.util.*;\n\npublic class QueueUsingStack {\n    \n    public static class Queue {\n        Stack<Integer> stack1 = new Stack<>();  // For enqueue\n        Stack<Integer> stack2 = new Stack<>();  // For dequeue\n        \n        public void enqueue(int value) {\n            stack1.push(value);\n        }\n        \n        public int dequeue() {\n            if(stack2.isEmpty()) {\n                // Move all from stack1 to stack2 (reverses order)\n                while(!stack1.isEmpty()) {\n                    stack2.push(stack1.pop());\n                }\n            }\n            if(stack2.isEmpty()) throw new RuntimeException(\"Queue empty\");\n            return stack2.pop();\n        }\n    }\n    \n    public static void main(String[] args) {\n        Queue q = new Queue();\n        \n        // Test case 1: Enqueue then dequeue\n        q.enqueue(1);\n        q.enqueue(2);\n        q.enqueue(3);\n        assert q.dequeue() == 1 : \"TC1 failed\";\n        assert q.dequeue() == 2 : \"TC1 failed\";\n        \n        // Test case 2: Interleaved operations\n        q.enqueue(4);\n        assert q.dequeue() == 3 : \"TC2 failed\";\n        assert q.dequeue() == 4 : \"TC2 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Enqueue:** O(1) - just push to stack1\n- **Dequeue:** O(1) amortized - elements transferred once\n\n---\n\n**Problem 4.11: Generate Numbers with Given Digits**\n\n*Statement:* Generate numbers from 1 to n using only digits 0 and 1.\n\nExample: n=5 → [1, 10, 11, 100, 101]\n\n```java\nimport java.util.*;\n\npublic class GenerateNumbers {\n    \n    public static List<String> generateNumbers(int n) {\n        List<String> result = new ArrayList<>();\n        Queue<String> queue = new LinkedList<>();\n        \n        queue.offer(\"1\");  // Start with 1\n        \n        while(queue.size() < n) {\n            String num = queue.poll();\n            result.add(num);\n            \n            // Generate next numbers by appending 0 and 1\n            queue.offer(num + \"0\");\n            queue.offer(num + \"1\");\n        }\n        \n        // Add remaining numbers\n        while(!queue.isEmpty() && result.size() < n) {\n            result.add(queue.poll());\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: First 5 numbers\n        List<String> r1 = generateNumbers(5);\n        assert r1.size() == 5 : \"TC1 failed\";\n        assert r1.get(0).equals(\"1\") : \"TC1 failed\";\n        assert r1.get(1).equals(\"10\") : \"TC1 failed\";\n        \n        // Test case 2: First 3 numbers\n        List<String> r2 = generateNumbers(3);\n        assert r2.get(2).equals(\"11\") : \"TC2 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n---\n\n**Problem 4.12: First Non-Repeating Character in Stream**\n\n*Statement:* Find first non-repeating character as you read a stream.\n\nExample: \"aabcc\" → Read 'a', read 'a', no non-rep, read 'b', 'b' is first non-rep...\n\n```java\nimport java.util.*;\n\npublic class FirstNonRepeating {\n    \n    public static void findFirstNonRepeatingStream(String s) {\n        Map<Character, Integer> charCount = new HashMap<>();\n        Queue<Character> queue = new LinkedList<>();\n        \n        System.out.println(\"Processing: \" + s);\n        for(char c : s.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n            queue.offer(c);\n            \n            // Remove characters that are repeated\n            while(!queue.isEmpty() && charCount.get(queue.peek()) > 1) {\n                queue.poll();\n            }\n            \n            // Print current first non-repeating\n            if(!queue.isEmpty()) {\n                System.out.println(\"After reading '\" + c + \"': \" + queue.peek());\n            } else {\n                System.out.println(\"After reading '\" + c + \"': None\");\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Regular stream\n        findFirstNonRepeatingStream(\"aabcc\");\n        \n        // Test case 2: All unique\n        findFirstNonRepeatingStream(\"abc\");\n        \n        System.out.println(\"✓ Demonstration complete!\");\n    }\n}\n```\n\n---"
        },
        {
          "id": "4.5",
          "title": "Hash Tables",
          "part": "Part 4: Basic Data Structures",
          "content": "#### Concept Explanation\n\n**What is a Hash Table?**\n\nA hash table is a data structure that implements an **associative array** - a structure that maps keys to values using a **hash function**.\n\nThink of it like a library catalog:\n- Key = Book name\n- Value = Book location\n- Hash function = Catalog system that instantly finds location\n\n```\nHash Table: {\n  \"Java\" → 8.5/5,\n  \"Python\" → 9.2/10,\n  \"C++\" → 7.8/10\n}\n```\n\n**Why Hash Tables Matter:**\n\n- **O(1) average lookup** - incredible for large datasets\n- **Caching** - store computed results\n- **Counting** - count frequencies efficiently\n- **Finding duplicates** - check if seen before\n\n**Memory Aid: \"KEY TO VALUE IN INSTANT TIME\"**\n\nHash function instantly converts key to array index!\n\n#### Key Concepts\n\n**1. How Hash Function Works**\n```\nHash Function: h(key) = key.hashCode() % tableSize\n\nExample:\n  h(\"Java\") = 12345 % 10 = 5    (Store at index 5)\n  h(\"Python\") = 67890 % 10 = 0  (Store at index 0)\n```\n\n**2. Collision Handling (Chaining)**\n```java\n// Multiple keys hash to same index\n// Solution: Store list of entries at that index\narr[5] = [\"Java\" → value1, \"Scala\" → value2]\n```\n\n**3. HashMap in Java**\n```java\nMap<String, Integer> map = new HashMap<>();\nmap.put(\"Java\", 100);      // O(1)\nint value = map.get(\"Java\"); // O(1)\nmap.remove(\"Java\");         // O(1)\n```\n\n#### Questions & Answers\n\n**Q1: What's a good hash function?**\n\nA: Good hash function:\n- Distributes keys uniformly (minimizes collisions)\n- Is consistent (same key always hashes to same value)\n- Is fast to compute\n\nBad hash functions cause clustering (collisions group together).\n\n**Q2: What's the difference between HashMap and TreeMap?**\n\nA:\n| Feature | HashMap | TreeMap |\n|---------|---------|---------|\n| Ordering | Random | Sorted by key |\n| Lookup | O(1) | O(log n) |\n| Use case | Fast lookup | Sorted iteration |\n\n**Q3: What happens on hash collision?**\n\nA: Two common strategies:\n1. **Chaining:** Store multiple values in list at index\n2. **Open Addressing:** Find another empty slot\n\nJava's HashMap uses chaining.\n\n#### Problems with Solutions\n\n**Problem 4.13: Two Sum**\n\n*Statement:* Find two elements in array that sum to target.\n\nExample: [2, 7, 11, 15], target=9 → [0, 1]\n\n```java\nimport java.util.*;\n\npublic class TwoSum {\n    \n    public static int[] twoSum(int[] arr, int target) {\n        Map<Integer, Integer> seen = new HashMap<>();\n        \n        for(int i = 0; i < arr.length; i++) {\n            int complement = target - arr[i];\n            \n            if(seen.containsKey(complement)) {\n                return new int[]{seen.get(complement), i};\n            }\n            \n            seen.put(arr[i], i);\n        }\n        \n        return new int[]{};  // Not found\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Solution exists\n        int[] r1 = twoSum(new int[]{2, 7, 11, 15}, 9);\n        assert r1[0] == 0 && r1[1] == 1 : \"TC1 failed\";\n        \n        // Test case 2: Multiple solutions\n        int[] r2 = twoSum(new int[]{3, 2, 4}, 6);\n        assert (r2[0] == 1 && r2[1] == 2) || (r2[0] == 2 && r2[1] == 1) : \"TC2 failed\";\n        \n        // Test case 3: No solution\n        int[] r3 = twoSum(new int[]{1, 2, 3}, 10);\n        assert r3.length == 0 : \"TC3 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n) - single pass with hash lookup\n- **Space:** O(n) - store elements in map\n\n**Key Insight:** Hash table transforms O(n²) brute force to O(n) solution!\n\n---\n\n**Problem 4.14: Group Anagrams**\n\n*Statement:* Group strings that are anagrams of each other.\n\nExample: [\"eat\",\"tea\",\"ate\",\"nat\",\"tan\",\"bat\"] → [[\"eat\",\"tea\",\"ate\"],[\"nat\",\"tan\"],[\"bat\"]]\n\n```java\nimport java.util.*;\n\npublic class GroupAnagrams {\n    \n    public static List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> groups = new HashMap<>();\n        \n        for(String str : strs) {\n            // Sort characters to get canonical form\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            \n            // Add to group\n            groups.putIfAbsent(key, new ArrayList<>());\n            groups.get(key).add(str);\n        }\n        \n        return new ArrayList<>(groups.values());\n    }\n    \n    public static void main(String[] args) {\n        // Test case 1: Regular anagrams\n        List<List<String>> r1 = groupAnagrams(new String[]{\"eat\", \"tea\", \"ate\"});\n        assert r1.size() == 1 : \"TC1 failed\";\n        assert r1.get(0).size() == 3 : \"TC1 failed\";\n        \n        // Test case 2: Mixed\n        List<List<String>> r2 = groupAnagrams(new String[]{\"a\"});\n        assert r2.size() == 1 : \"TC2 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Time:** O(n * k log k) - n words, sorting k characters each\n- **Space:** O(n * k) - store all characters\n\n---\n\n**Problem 4.15: LRU Cache**\n\n*Statement:* Implement Least Recently Used cache with fixed capacity.\n\n```java\nimport java.util.*;\n\npublic class LRUCache {\n    \n    public static class Node {\n        int key, value;\n        Node prev, next;\n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    int capacity;\n    Map<Integer, Node> cache = new HashMap<>();\n    Node head = new Node(0, 0);  // Dummy head\n    Node tail = new Node(0, 0);  // Dummy tail\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    private void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    public int get(int key) {\n        if(!cache.containsKey(key)) return -1;\n        \n        Node node = cache.get(key);\n        remove(node);\n        addToHead(node);  // Mark as recently used\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if(cache.containsKey(key)) {\n            Node node = cache.get(key);\n            remove(node);\n            node.value = value;\n            addToHead(node);\n        } else {\n            if(cache.size() == capacity) {\n                // Remove least recently used (before tail)\n                Node lru = tail.prev;\n                remove(lru);\n                cache.remove(lru.key);\n            }\n            \n            Node newNode = new Node(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n        }\n    }\n    \n    public static void main(String[] args) {\n        LRUCache cache = new LRUCache(2);\n        \n        // Test case 1: Basic operations\n        cache.put(1, 1);\n        cache.put(2, 2);\n        assert cache.get(1) == 1 : \"TC1 failed\";\n        \n        cache.put(3, 3);  // Evicts key 2\n        assert cache.get(2) == -1 : \"TC1 failed\";\n        \n        cache.put(4, 4);  // Evicts key 1\n        assert cache.get(1) == -1 : \"TC1 failed\";\n        assert cache.get(3) == 3 : \"TC1 failed\";\n        assert cache.get(4) == 4 : \"TC1 failed\";\n        \n        System.out.println(\"✓ All test cases passed!\");\n    }\n}\n```\n\n**Complexity Analysis:**\n- **Get:** O(1)\n- **Put:** O(1)\n- **Space:** O(capacity)\n\n**Key Insight:** Doubly linked list + HashMap is perfect for LRU!\n\n---"
        },
        {
          "id": "5.1",
          "title": "Sorting Fundamentals",
          "part": "Part 5: Sorting",
          "content": "#### Concept Explanation\n\n**What are Sorting Algorithms?**\n\nSorting algorithms arrange elements in specific order (usually ascending). Choosing right algorithm matters:\n- Small data? → Simple O(n²) fine\n- Large data? → Need O(n log n)\n- Nearly sorted? → Insertion sort beats everyone\n\n**Memory Aid: \"RIGHT TOOL FOR RIGHT JOB\"**\n\nNo single best algorithm. Trade-offs between:\n- **Time complexity** - speed\n- **Space complexity** - memory\n- **Stability** - preserve order of equal elements\n- **Adaptive** - faster on partially sorted data\n\n#### Common Sorting Algorithms Overview\n\n```\nName          | Time (Best) | Time (Average) | Time (Worst) | Space | Stable\n--------------|-------------|----------------|--------------|-------|--------\nBubble Sort   | O(n)        | O(n²)          | O(n²)        | O(1)  | Yes\nInsertion Sort| O(n)        | O(n²)          | O(n²)        | O(1)  | Yes\nSelection Sort| O(n²)       | O(n²)          | O(n²)        | O(1)  | No\nMerge Sort    | O(n log n)  | O(n log n)     | O(n log n)   | O(n)  | Yes\nQuick Sort    | O(n log n)  | O(n log n)     | O(n²)        | O(1)  | No\nHeap Sort     | O(n log n)  | O(n log n)     | O(n log n)   | O(1)  | No\n```\n\n---"
        },
        {
          "id": "5.2",
          "title": "Bubble Sort",
          "part": "Part 5: Sorting",
          "content": "#### Concept Explanation\n\n**How Bubble Sort Works:**\n\n1. Compare adjacent elements\n2. Swap if they're in wrong order\n3. Repeat until no swaps needed\n4. Largest element \"bubbles\" to end each pass\n\n**Visual:**\n```\nPass 1: [5,3,8,4,2] → [3,5,4,2,8]    (8 bubbles to end)\nPass 2: [3,5,4,2,8] → [3,4,2,5,8]    (5 bubbles)\nPass 3: [3,4,2,5,8] → [3,2,4,5,8]    (4 bubbles)\nPass 4: [3,2,4,5,8] → [2,3,4,5,8]    (sorted)\n```\n\n#### Implementation\n\n```java\npublic class BubbleSort {\n    \n    public static void bubbleSort(int[] arr) {\n        int n = arr.length;\n        \n        for(int i = 0; i < n - 1; i++) {\n            boolean swapped = false;\n            \n            // Last i elements are in position\n            for(int j = 0; j < n - i - 1; j++) {\n                if(arr[j] > arr[j + 1]) {\n                    // Swap\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n            // Optimization: if no swaps, array is sorted\n            if(!swapped) break;\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        bubbleSort(arr);\n        assert java.util.Arrays.equals(arr, new int[]{11, 12, 22, 25, 34, 64, 90}) : \"Failed\";\n        System.out.println(\"✓ Bubble Sort test passed!\");\n    }\n}\n```\n\n**Complexity:**\n- **Time:** O(n²) worst/average, **O(n)** best (already sorted)\n- **Space:** O(1)\n- **Stable:** Yes\n\n**When to use:** Educational purposes only. Too slow for real use.\n\n---"
        },
        {
          "id": "5.3",
          "title": "Merge Sort",
          "part": "Part 5: Sorting",
          "content": "#### Concept Explanation\n\n**How Merge Sort Works:**\n\n1. **Divide:** Split array in half recursively\n2. **Conquer:** Sort left and right halves\n3. **Merge:** Combine two sorted arrays\n\n**Visual:**\n```\n[38,27,43,3,9,82,10]\n        ↓ Divide\n[38,27,43,3]  [9,82,10]\n   ↓ Divide      ↓ Divide\n[38,27][43,3]  [9,82][10]\n  ↓ Sort        ↓ Sort\n[27,38][3,43]  [9,82][10]\n   ↓ Merge        ↓ Merge\n[3,27,38,43]  [9,10,82]\n      ↓ Merge\n[3,9,10,27,38,43,82]\n```\n\n#### Implementation\n\n```java\npublic class MergeSort {\n    \n    public static void mergeSort(int[] arr) {\n        if(arr.length <= 1) return;\n        \n        mergeSort(arr, 0, arr.length - 1);\n    }\n    \n    private static void mergeSort(int[] arr, int left, int right) {\n        if(left < right) {\n            int mid = left + (right - left) / 2;\n            \n            mergeSort(arr, left, mid);      // Sort left half\n            mergeSort(arr, mid + 1, right); // Sort right half\n            merge(arr, left, mid, right);   // Merge halves\n        }\n    }\n    \n    private static void merge(int[] arr, int left, int mid, int right) {\n        int[] temp = new int[right - left + 1];\n        int i = left, j = mid + 1, k = 0;\n        \n        // Merge two sorted halves\n        while(i <= mid && j <= right) {\n            if(arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n            }\n        }\n        \n        // Copy remaining elements\n        while(i <= mid) temp[k++] = arr[i++];\n        while(j <= right) temp[k++] = arr[j++];\n        \n        // Copy back to original array\n        for(i = left, k = 0; i <= right; i++, k++) {\n            arr[i] = temp[k];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] arr = {38, 27, 43, 3, 9, 82, 10};\n        mergeSort(arr);\n        assert java.util.Arrays.equals(arr, new int[]{3, 9, 10, 27, 38, 43, 82}) : \"Failed\";\n        System.out.println(\"✓ Merge Sort test passed!\");\n    }\n}\n```\n\n**Complexity:**\n- **Time:** O(n log n) guaranteed all cases\n- **Space:** O(n) for temporary array\n- **Stable:** Yes\n\n**When to use:** When you need guaranteed O(n log n) and stability matters.\n\n---"
        },
        {
          "id": "5.4",
          "title": "Quick Sort",
          "part": "Part 5: Sorting",
          "content": "#### Concept Explanation\n\n**How Quick Sort Works:**\n\n1. **Partition:** Choose pivot, split into smaller and larger\n2. **Recursively:** Sort left and right partitions\n3. **Combine:** Already in place!\n\n**Visual:**\n```\n[64,34,25,12,22,11,90]\n       ↓ Partition around 64\n[34,25,12,22,11] 64 [90]\n    ↓ Recurse\n[11,12,22,25,34] 64 [90]\n```\n\n#### Implementation\n\n```java\npublic class QuickSort {\n    \n    public static void quickSort(int[] arr) {\n        if(arr.length == 0) return;\n        quickSort(arr, 0, arr.length - 1);\n    }\n    \n    private static void quickSort(int[] arr, int low, int high) {\n        if(low < high) {\n            int pi = partition(arr, low, high);\n            quickSort(arr, low, pi - 1);   // Sort left\n            quickSort(arr, pi + 1, high);  // Sort right\n        }\n    }\n    \n    private static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        \n        for(int j = low; j < high; j++) {\n            if(arr[j] < pivot) {\n                i++;\n                // Swap\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        \n        // Place pivot in correct position\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        return i + 1;\n    }\n    \n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        quickSort(arr);\n        assert java.util.Arrays.equals(arr, new int[]{11, 12, 22, 25, 34, 64, 90}) : \"Failed\";\n        System.out.println(\"✓ Quick Sort test passed!\");\n    }\n}\n```\n\n**Complexity:**\n- **Time:** O(n log n) average, O(n²) worst\n- **Space:** O(log n) recursion stack\n- **Stable:** No (typical implementation)\n\n**When to use:** Most practical sorting algorithm. Fast in practice.\n\n**Optimization:** Randomize pivot selection to avoid O(n²) on sorted data.\n\n---\n\n## CONTINUATION ROADMAP\n\n### Part 6: Search Algorithms\n- Linear Search (O(n))\n- Binary Search (O(log n))\n\n### Part 7: Tree Data Structures\n- Binary Trees\n- Binary Search Trees\n- Tree Traversals\n- Balanced Trees (AVL, Red-Black)\n\n### Part 8: Graph Data Structures\n- Graph Representations\n- BFS & DFS\n- Shortest Path (Dijkstra, Bellman-Ford)\n- Minimum Spanning Trees (Prim's, Kruskal's)\n\n### Part 9: Advanced Data Structures\n- Trie\n- Segment Trees\n- Fenwick Trees\n- Union-Find\n\n### Part 10: Problem Solving Techniques\n- Recursion & Backtracking\n- Greedy Algorithms\n- Dynamic Programming\n- Divide & Conquer\n- Two Pointer Technique\n- Sliding Window\n\n---\n\n## Study Guide & Best Practices\n\n### How to Use This Module\n\n1. **Read Concept Explanation** - Understand the \"why\"\n2. **Remember Key Takeaway** - Use memory aids for retention\n3. **Study Implementation** - Trace through code step by step\n4. **Solve All Problems** - Build intuition through practice\n5. **Modify & Experiment** - Change constraints and values\n\n### Interview Preparation Strategy\n\n**Phase 1: Foundation (Weeks 1-4)**\n- Understand all basic data structures\n- Implement from scratch (without library code)\n- Solve 30+ easy problems\n\n**Phase 2: Intermediate (Weeks 5-8)**\n- Learn sorting and searching algorithms\n- Solve 50+ medium problems\n- Practice explaining solutions\n\n**Phase 3: Advanced (Weeks 9-12)**\n- Study trees and graphs\n- Solve 30+ hard problems\n- Time-box problems (40 min max)\n\n### Practice Platforms\n- **LeetCode** - Best for interview prep\n- **HackerRank** - Step-by-step guidance\n- **GeeksforGeeks** - Additional explanations\n- **CodeSignal** - Timed challenges\n\n### Key Reminders\n\n✓ **Consistency beats intensity** - 30 min daily > 5 hour marathon  \n✓ **Write code on paper first** - Builds muscle memory  \n✓ **Explain your solution** - Practice verbal communication  \n✓ **Optimize always** - Discuss trade-offs  \n✓ **Test edge cases** - Empty arrays, single elements, duplicates  \n\n---\n\n**Happy Learning! You've got this! 🚀**"
        }
      ]
    }
  ]
}
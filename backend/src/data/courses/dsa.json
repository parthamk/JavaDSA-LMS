{
  "id": "dsa",
  "title": "Data Structures & Algorithms Mastery",
  "description": "Learn essential data structures and algorithms with practical examples and interview prep",
  "difficulty": "Intermediate to Advanced",
  "duration": "45+ hours",
  "sections": [
    {
      "id": "1",
      "number": "1.1",
      "title": "Introduction to DSA",
      "subsections": [
        {
          "id": "1-1",
          "title": "What is DSA?",
          "type": "content",
          "content": "Data Structures and Algorithms (DSA) are fundamental concepts for solving computational problems efficiently.",
          "keyPoints": [
            {
              "label": "Data Structures",
              "description": "Ways to organize and store data"
            },
            {
              "label": "Algorithms",
              "description": "Step-by-step procedures to solve problems"
            },
            {
              "label": "Efficiency",
              "description": "Optimizing time and space complexity"
            },
            {
              "label": "Problem Solving",
              "description": "Critical skill for coding interviews"
            }
          ]
        }
      ]
    },
    {
      "id": "2",
      "number": "1.2",
      "title": "Arrays and Lists",
      "subsections": [
        {
          "id": "2-1",
          "title": "Array Operations",
          "type": "table",
          "data": [
            {
              "Operation": "Access",
              "Time": "O(1)",
              "Description": "Direct index access"
            },
            {
              "Operation": "Search",
              "Time": "O(n)",
              "Description": "Linear search"
            },
            {
              "Operation": "Insert",
              "Time": "O(n)",
              "Description": "May require shifting"
            },
            {
              "Operation": "Delete",
              "Time": "O(n)",
              "Description": "May require shifting"
            }
          ]
        },
        {
          "id": "2-2",
          "title": "Finding Maximum Element",
          "type": "code",
          "language": "java",
          "code": "public static int findMax(int[] arr) {\n    int max = arr[0];\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\nint[] numbers = {5, 2, 8, 1, 9};\nSystem.out.println(findMax(numbers));  // 9",
          "explanation": "Time Complexity: O(n) - Single pass through array"
        }
      ]
    },
    {
      "id": "3",
      "number": "1.3",
      "title": "Linked Lists",
      "subsections": [
        {
          "id": "3-1",
          "title": "Node Class",
          "type": "code",
          "language": "java",
          "code": "public class Node {\n    int data;\n    Node next;\n    \n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}"
        },
        {
          "id": "3-2",
          "title": "LinkedList Operations",
          "type": "table",
          "data": [
            {
              "Operation": "Access",
              "Time": "O(n)",
              "Description": "Need to traverse"
            },
            {
              "Operation": "Search",
              "Time": "O(n)",
              "Description": "Linear search"
            },
            {
              "Operation": "Insert at Head",
              "Time": "O(1)",
              "Description": "Constant time"
            },
            {
              "Operation": "Delete at Head",
              "Time": "O(1)",
              "Description": "Constant time"
            }
          ]
        }
      ]
    },
    {
      "id": "4",
      "number": "2.1",
      "title": "Stacks",
      "subsections": [
        {
          "id": "4-1",
          "title": "Stack Basics (LIFO)",
          "type": "content",
          "content": "Stack follows Last-In-First-Out (LIFO) principle. Last element added is first to be removed.",
          "keyPoints": [
            {
              "label": "Push",
              "description": "Add element to top - O(1)"
            },
            {
              "label": "Pop",
              "description": "Remove from top - O(1)"
            },
            {
              "label": "Peek",
              "description": "View top element - O(1)"
            },
            {
              "label": "Use Cases",
              "description": "Undo/Redo, Browser history, Expression evaluation"
            }
          ]
        },
        {
          "id": "4-2",
          "title": "Stack Implementation",
          "type": "code",
          "language": "java",
          "code": "public class Stack {\n    private int[] arr;\n    private int top = -1;\n    private int capacity;\n    \n    public Stack(int capacity) {\n        this.capacity = capacity;\n        this.arr = new int[capacity];\n    }\n    \n    public void push(int value) {\n        if (top == capacity - 1) {\n            System.out.println(\"Stack Overflow\");\n            return;\n        }\n        arr[++top] = value;\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            System.out.println(\"Stack Underflow\");\n            return -1;\n        }\n        return arr[top--];\n    }\n}"
        }
      ]
    },
    {
      "id": "5",
      "number": "2.2",
      "title": "Queues",
      "subsections": [
        {
          "id": "5-1",
          "title": "Queue Basics (FIFO)",
          "type": "content",
          "content": "Queue follows First-In-First-Out (FIFO) principle. First element added is first to be removed.",
          "keyPoints": [
            {
              "label": "Enqueue",
              "description": "Add to rear - O(1)"
            },
            {
              "label": "Dequeue",
              "description": "Remove from front - O(1)"
            },
            {
              "label": "Peek",
              "description": "View front element - O(1)"
            },
            {
              "label": "Use Cases",
              "description": "BFS, CPU scheduling, Print queue"
            }
          ]
        },
        {
          "id": "5-2",
          "title": "Queue Implementation",
          "type": "code",
          "language": "java",
          "code": "public class Queue {\n    private int[] arr;\n    private int front = 0, rear = -1;\n    private int capacity;\n    \n    public Queue(int capacity) {\n        this.capacity = capacity;\n        this.arr = new int[capacity];\n    }\n    \n    public void enqueue(int value) {\n        if (rear == capacity - 1) {\n            System.out.println(\"Queue is Full\");\n            return;\n        }\n        arr[++rear] = value;\n    }\n    \n    public int dequeue() {\n        if (front > rear) {\n            System.out.println(\"Queue is Empty\");\n            return -1;\n        }\n        return arr[front++];\n    }\n}"
        }
      ]
    },
    {
      "id": "6",
      "number": "3.1",
      "title": "Sorting Algorithms",
      "subsections": [
        {
          "id": "6-1",
          "title": "Sorting Complexity Comparison",
          "type": "table",
          "data": [
            {
              "Algorithm": "Bubble Sort",
              "Best": "O(n)",
              "Average": "O(n²)",
              "Worst": "O(n²)",
              "Space": "O(1)"
            },
            {
              "Algorithm": "Selection Sort",
              "Best": "O(n²)",
              "Average": "O(n²)",
              "Worst": "O(n²)",
              "Space": "O(1)"
            },
            {
              "Algorithm": "Insertion Sort",
              "Best": "O(n)",
              "Average": "O(n²)",
              "Worst": "O(n²)",
              "Space": "O(1)"
            },
            {
              "Algorithm": "Merge Sort",
              "Best": "O(n log n)",
              "Average": "O(n log n)",
              "Worst": "O(n log n)",
              "Space": "O(n)"
            },
            {
              "Algorithm": "Quick Sort",
              "Best": "O(n log n)",
              "Average": "O(n log n)",
              "Worst": "O(n²)",
              "Space": "O(log n)"
            }
          ]
        },
        {
          "id": "6-2",
          "title": "Bubble Sort",
          "type": "code",
          "language": "java",
          "code": "public static void bubbleSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // Swap\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}",
          "explanation": "Time: O(n²), Space: O(1) - Simple but inefficient for large datasets"
        }
      ]
    },
    {
      "id": "7",
      "number": "3.2",
      "title": "Searching Algorithms",
      "subsections": [
        {
          "id": "7-1",
          "title": "Linear Search",
          "type": "code",
          "language": "java",
          "code": "public static int linearSearch(int[] arr, int target) {\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}",
          "explanation": "Time: O(n) - Works on unsorted arrays"
        },
        {
          "id": "7-2",
          "title": "Binary Search",
          "type": "code",
          "language": "java",
          "code": "public static int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}",
          "explanation": "Time: O(log n) - Requires sorted array. Much faster than linear search"
        }
      ]
    },
    {
      "id": "8",
      "number": "4.1",
      "title": "Trees",
      "subsections": [
        {
          "id": "8-1",
          "title": "Binary Tree Node",
          "type": "code",
          "language": "java",
          "code": "public class TreeNode {\n    int data;\n    TreeNode left;\n    TreeNode right;\n    \n    public TreeNode(int data) {\n        this.data = data;\n        this.left = null;\n        this.right = null;\n    }\n}"
        },
        {
          "id": "8-2",
          "title": "Tree Traversals",
          "type": "code",
          "language": "java",
          "code": "// InOrder: Left -> Root -> Right\npublic static void inOrder(TreeNode node) {\n    if (node == null) return;\n    inOrder(node.left);\n    System.out.print(node.data + \" \");\n    inOrder(node.right);\n}\n\n// PreOrder: Root -> Left -> Right\npublic static void preOrder(TreeNode node) {\n    if (node == null) return;\n    System.out.print(node.data + \" \");\n    preOrder(node.left);\n    preOrder(node.right);\n}\n\n// PostOrder: Left -> Right -> Root\npublic static void postOrder(TreeNode node) {\n    if (node == null) return;\n    postOrder(node.left);\n    postOrder(node.right);\n    System.out.print(node.data + \" \");\n}"
        }
      ]
    },
    {
      "id": "9",
      "number": "4.2",
      "title": "Graphs",
      "subsections": [
        {
          "id": "9-1",
          "title": "Graph Representations",
          "type": "table",
          "data": [
            {
              "Type": "Adjacency Matrix",
              "Space": "O(V²)",
              "Add Edge": "O(1)",
              "Remove Edge": "O(1)",
              "Best For": "Dense graphs"
            },
            {
              "Type": "Adjacency List",
              "Space": "O(V+E)",
              "Add Edge": "O(1)",
              "Remove Edge": "O(E)",
              "Best For": "Sparse graphs"
            }
          ]
        },
        {
          "id": "9-2",
          "title": "BFS (Breadth-First Search)",
          "type": "code",
          "language": "java",
          "code": "public static void bfs(int[][] graph, int start) {\n    boolean[] visited = new boolean[graph.length];\n    Queue<Integer> queue = new LinkedList<>();\n    \n    queue.add(start);\n    visited[start] = true;\n    \n    while (!queue.isEmpty()) {\n        int node = queue.remove();\n        System.out.print(node + \" \");\n        \n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                queue.add(neighbor);\n                visited[neighbor] = true;\n            }\n        }\n    }\n}",
          "explanation": "Time: O(V+E) - Explores level by level using Queue"
        }
      ]
    },
    {
      "id": "10",
      "number": "5.1",
      "title": "Dynamic Programming",
      "subsections": [
        {
          "id": "10-1",
          "title": "Introduction to DP",
          "type": "content",
          "content": "Dynamic Programming is an optimization technique that solves complex problems by breaking them into simpler subproblems.",
          "keyPoints": [
            {
              "label": "Overlapping Subproblems",
              "description": "Same subproblems solved multiple times"
            },
            {
              "label": "Optimal Substructure",
              "description": "Optimal solution from optimal subproblems"
            },
            {
              "label": "Memoization",
              "description": "Store results to avoid recomputation"
            },
            {
              "label": "Tabulation",
              "description": "Build solution iteratively from bottom-up"
            }
          ]
        },
        {
          "id": "10-2",
          "title": "Fibonacci with Memoization",
          "type": "code",
          "language": "java",
          "code": "public static long fibonacci(int n, Map<Integer, Long> memo) {\n    if (n <= 1) return n;\n    \n    if (memo.containsKey(n)) {\n        return memo.get(n);\n    }\n    \n    long result = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    memo.put(n, result);\n    return result;\n}\n\nMap<Integer, Long> memo = new HashMap<>();\nSystem.out.println(fibonacci(10, memo));  // 55",
          "explanation": "Time: O(n) - Each subproblem computed once"
        }
      ]
    }
  ],
  "interviewQuestions": [
    {
      "id": "q1",
      "question": "What is the difference between Array and LinkedList?",
      "answer": "Array has O(1) access but O(n) insertion. LinkedList has O(n) access but O(1) insertion at head."
    },
    {
      "id": "q2",
      "question": "Explain time and space complexity",
      "answer": "Time complexity measures algorithm efficiency in execution. Space complexity measures memory usage."
    },
    {
      "id": "q3",
      "question": "What is Big O notation?",
      "answer": "Big O describes worst-case performance of an algorithm as input size grows."
    },
    {
      "id": "q4",
      "question": "Difference between Stack and Queue?",
      "answer": "Stack is LIFO (Last-In-First-Out). Queue is FIFO (First-In-First-Out)."
    },
    {
      "id": "q5",
      "question": "What are the advantages of Binary Search Tree?",
      "answer": "Sorted data, O(log n) search/insert/delete in balanced BST, useful for range queries."
    },
    {
      "id": "q6",
      "question": "Explain DFS and BFS",
      "answer": "DFS explores deep first using stack (recursive). BFS explores level by level using queue."
    },
    {
      "id": "q7",
      "question": "What is Dynamic Programming?",
      "answer": "Technique to solve complex problems by breaking into subproblems and storing results."
    }
  ],
  "practiceProblems": [
    {
      "id": "p1",
      "title": "Find Maximum Element",
      "difficulty": "Easy",
      "description": "Find the maximum element in an array",
      "code": "public static int findMax(int[] arr) {\n    int max = arr[0];\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] > max) max = arr[i];\n    }\n    return max;\n}",
      "testCases": [
        { "input": "[5, 2, 8, 1, 9]", "output": "9" },
        { "input": "[1]", "output": "1" },
        { "input": "[-5, -2, -10]", "output": "-2" }
      ]
    },
    {
      "id": "p2",
      "title": "Reverse an Array",
      "difficulty": "Easy",
      "description": "Reverse the elements of an array",
      "code": "public static void reverseArray(int[] arr) {\n    int left = 0, right = arr.length - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n}",
      "testCases": [
        { "input": "[1, 2, 3, 4, 5]", "output": "[5, 4, 3, 2, 1]" },
        { "input": "[1]", "output": "[1]" }
      ]
    },
    {
      "id": "p3",
      "title": "Two Sum Problem",
      "difficulty": "Medium",
      "description": "Find two numbers that add up to target",
      "code": "public static int[] twoSum(int[] arr, int target) {\n    Set<Integer> seen = new HashSet<>();\n    for (int num : arr) {\n        if (seen.contains(target - num)) {\n            return new int[]{target - num, num};\n        }\n        seen.add(num);\n    }\n    return new int[]{-1, -1};\n}",
      "testCases": [
        { "input": "[2, 7, 11, 15], 9", "output": "[2, 7]" },
        { "input": "[3, 2, 4], 6", "output": "[2, 4]" }
      ]
    },
    {
      "id": "p4",
      "title": "Fibonacci Number",
      "difficulty": "Medium",
      "description": "Calculate nth Fibonacci number efficiently",
      "code": "public static long fibonacci(int n, Map<Integer, Long> memo) {\n    if (n <= 1) return n;\n    if (memo.containsKey(n)) return memo.get(n);\n    long result = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    memo.put(n, result);\n    return result;\n}",
      "testCases": [
        { "input": "10", "output": "55" },
        { "input": "5", "output": "5" },
        { "input": "0", "output": "0" }
      ]
    }
  ],
  "lastUpdated": "2025-11-19",
  "version": "1.0"
}
